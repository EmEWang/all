

STL容器底层实现

1 顺序容器
容器       数据结构
vector     数组
list       双向链表
deque      数个缓冲区相接，由一个中央控制器管理

           随机访问                      内存管理                        增删元素
vector 支持快速随机访问，一次指针解引用    扩充时须将所有的元素拷贝到新位置   在尾部可快速增删，中间插入会导致之后的元素拷贝
list   不支持随机访问                    为各节点单独分配内存              在任意位置都可快速增删
deque  支持随机访问，两次指针解引用       按需扩充一个缓冲区大小，无需拷贝   在头尾可快速增删，中间插入会导致元素拷贝
       （中央控制器和缓冲区两次）

2 关联容器    可快速查找（ O(logN) ）的容器，且可按键排序。
容器       数据结构  集合内容  键是否唯一
set        红黑树    键       是
map        红黑树    键值对   是
multiset   红黑树    键       否
multimap   红黑树    键值对   否
关联容器底层数据结构均为红黑树，因为红黑树性能平均下来最好，也因此这四个容器行为类似，一般操作时间复杂度一般均为O(logN)，差别仅在于是键集合还是键值对集合，以及键是否可重复。

3 无序关联容器  从 C++11 开始提供的可快速查找（均摊O(1)，最坏O(n) ）的无序容器。
容器                     数据结构  集合内容  键是否唯一
unordered_set            哈希表    键       是
unordered_map            哈希表    键值对   是
unordered_multiset       哈希表    键       否
unordered_multimap       哈希表    键值对   否
相对于关联容器，上层行为表现一致，底层数据结构更换为了哈希表获得了更好的均摊性能，但同时付出了不可按序访问的代价。

4 容器适配器 在其他容器的接口上进行封装和改写实现。
容器              默认底层容器    描述
stack             deque          堆栈，后进先出（LIFO）
queue             deque          队列，先进先出（FIFO）
priority_queue    vector         优先队列
stack 和 queue 默认用 deque 实现为了让当数据量很大时，不会因元素移动导致过多的时间消耗。而 priority_queue 利用 vector 则是因为为了实现优先队列用到了 heap 相关的函数，其中用到了大量的随机访问。





hash_map

hash_map基于hash table（哈希表）。哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存,用空间换时间的做法是值得的。

1 基本原理：使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。
但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。

hash_map，首先分配一大片内存，形成许多桶。是利用hash函数，对key进行映射到不同区域（桶）进行保存。其插入过程是：
1 得到key
2 通过hash函数得到hash值
3 得到桶号(一般都为hash值对桶数求模)
4 存放key和value在桶内。

其取值过程是:
1 得到key
2 通过hash函数得到hash值
3 得到桶号(一般都为hash值对桶数求模)
4 比较桶的内部元素是否与key相等，若都不相等，则没有找到。
5 取出相等的记录的value。
hash_map中直接地址用hash函数生成，解决冲突，用比较函数解决。这里可以看出，如果每个桶内部只有一个元素，那么查找的时候只有一次比较。当许多桶内没有值时，许多查询就会更快了(指查不到的时候).
由此可见，要实现哈希表, 和用户相关的是：hash函数和比较函数。这两个参数刚好是我们在使用hash_map时需要指定的参数。

2 实现
hash_map类在头文件hash_map中
#include <hash_map>
using namespace std;
using namespace stdext;

hash_map是一个聚合类，它继承自_Hash类，包括一个vector，一个list和一个pair，其中vector用于保存桶，list用于进行冲突处理，pair用于保存key->value结构
template<class _Key, class _Tp, class _HashFn = hash<_Key>,
  class _EqualKey = equal_to<_Key>, class _Alloc = allocator<_Tp> >
class hash_map {
  ...
private:
  typedef pair<_Key, _Tp> hash_pair;
  typedef list<hash_pair>    hash_list;
  typedef vector<hash_list>  hash_table;
}


2.1 hash函数
SGI STL中，提供了以下hash函数
struct hash<char*>
struct hash<const char*>
struct hash<char>
struct hash<unsigned char>
struct hash<signed char>
struct hash<short>
struct hash<unsigned short>
struct hash<int>
struct hash<unsigned int>
struct hash<long>
struct hash<unsigned long>

若key是以上类型之一，可使用缺省的hash函数，当然也可自定义。对于自定义变量，只能自定hash函数义，如对于string。
struct str_hash{
  size_t operator()(const string& str) const
  {
    unsigned long __h = 0;
    for (size_t i = 0 ; i < str.size() ; i ++)
    __h = 5*__h + str[i];
    return size_t(__h);
  }
};
利用系统定义的字符串hash函数，你可以这样写：
struct str_hash{
  size_t operator()(const string& str) const
  {
    return __stl_hash_string(str.c_str());
  }
};

在声明自己的哈希函数时要注意以下几点：
1 使用struct，然后重载operator().
2 返回是size_t
3 参数是你要hash的key的类型。
4 函数是const类型的。

hash_map<string, string, str_hash> namemap;     //应用自定义hash 函数

2.2 比较函数
map 的比较函数，需要提供less函数，缺省的也是less< Key> 。hash_map需要的是是否等于的函数:equal_to< Key>
//本代码可以从SGI STL
//先看看binary_function 函数声明，其实只是定义一些类型而已。
template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
};
//看看equal_to的定义：
template <class _Tp>
struct equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }
};


在一个自定义的数据类型中使用比较函数，有两种方法. 第一种是：重载==操作符，利用equal_to;如下
struct mystruct{
  int iID;
  int  len;
  bool operator==(const mystruct & my) const{
    return (iID==my.iID) && (len==my.len) ;
  }
};
这样，就可以使用equal_to< mystruct>作为比较函数了。另一种方法就是使用函数对象。自定义一个比较函数体：
struct compare_str{
  bool operator()(const char* p1, const char*p2) const{
    return strcmp(p1,p2)==0;
  }
};
有了compare_str，就可以使用hash_map了。
typedef hash_map<const char*, string, hash<const char*>, compare_str> StrIntMap;


3 hash_map 方法
1 hash_map(size_type n)  #n设置hash_map桶的个数。n越大，hash函数发生冲突的概率就越小，重新申请内存的概率就越小，效率越高。
2 const_iterator find(const key_type& k) const  #用查找，输入为键值，返回为迭代器。
3 data_type& operator[](const key_type& k)  #当使用[key]操作符时，如果容器中没有key元素，就自动增加了一个key元素。
4 insert  #插入元素，hash_map会自动申请更大的内存，以生成更多的桶。因此在insert以后，以前的iterator有可能是不可用的。
5 erase  #在sgi stl中是erase并不自动回收内存。因此你调用erase后，其他元素的iterator还是可用的。
6 size()  #保存的元素个数
7 bucket_count()  #桶大小

4 自定义类型hash_map 实例
class ClassA{public:int get()const { return a;}  int a;}; #定义类
struct hash_A{size_t operator()(const ClassA & A)const{return A.get();}}; #定义hash函数
struct equal_A{bool operator()(const ClassA &a, const ClassA &b)const{return a.get() == b.get();}}; #定义等方法
hash_map<ClassA, string, hash_A, equal_A> hmap;          #使用


5 其他
相关hash容器
hash 容器除了hash_map之外，还有hash_set, hash_multimap, has_multiset 。

hash_map和map的区别
构造函数 hash_map需要hash函数 和 等于函数  map只需要比较函数(小于函数)
存储结构 hash_map采用hash表存储            map一般采用红黑树(RB Tree)实现

总体来说，hash_map 查找速度会比map快，常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n)小，hash还有hash函数的耗时，而且hash_map的构造速度较慢。




跳表 skip list
跳表是为了加速有序链表的访问速度。增加多层索引。访问速度为logn

        v1 -> v2 -> v3 -> v4 -> v5 -> v6 -> v7 -> v8 -> v9                 原始链表
                                ↓      进化为
                                ↓
        i1 -------> i2 -------> i3 -------> i4 -------> i5                 第一级索引
        ↓           ↓            ↓           ↓
        v1 -> v2 -> v3 -> v4 -> v5 -> v6 -> v7 -> v8 -> v9                 原始链表
                                ↓      进化为
                                ↓
        i1 -------------------> i2 -------------------> i3                 第二级索引
        ↓                        ↓                       ↓
        i1 -------> i2 -------> i3 -------> i4 -------> i5                 第一级索引
        ↓           ↓            ↓           ↓          ↓
        v1 -> v2 -> v3 -> v4 -> v5 -> v6 -> v7 -> v8 -> v9                 原始链表
                                ↓      进化为
                                ↓
        i1 -------------------------------------------> i2                 第三级索引
        ↓                                                ↓
        i1 -------------------> i2 -------------------> i3                 第二级索引
        ↓                        ↓                       ↓
        i1 -------> i2 -------> i3 -------> i4 -------> i5                 第一级索引
        ↓           ↓            ↓           ↓          ↓
        v1 -> v2 -> v3 -> v4 -> v5 -> v6 -> v7 -> v8 -> v9                 原始链表



树 tree
https://zhuanlan.zhihu.com/p/27700617
https://blog.csdn.net/v_JULY_v/article/details/6530142/
https://www.cnblogs.com/nullzx/p/8729425.html
1 从二分法到二叉树
以下为查找节点8的二分发过程 这就演化出了树和跳表两种数据结构，以下专注了解树的结构
        v1 -> v2 -> v3 -> v4 -> v5 -> v6 -> v7 -> v8 -> v9                 原始有序表
                                ↓
        v1 -> v2 -> v3 -> v4 -> v5 -> v6 -> v7 -> v8 -> v9                 获取中间节点5
                                            ↓
        v1 -> v2 -> v3 -> v4 -> v5 -> v6 -> v7 -> v8 -> v9                 获取中间节点7
                                                  ↓
        v1 -> v2 -> v3 -> v4 -> v5 -> v6 -> v7 -> v8 -> v9                 获取中间节点8 找到结果

                                ↓      转化为
                                ↓

                                v5
                             ↙      ↘
                           v3         v7
                         ↙  ↘       ↙   ↘
                      v2     v4     v6    v8
                     ↙                      ↘
                  v1                         v9

2 从二叉查树到平衡二叉树
二叉查找树充分了利用二分法的思维提升了数据查找的效率，但是同样的数据插入的先后顺序不一样，可能出现树高度差剧变的结构，极端情况可能会退化为链表。
                                v1
                                   ↘
                                     v2
                                       ↘
                                         v3
                                           ↘
                                            v4

3 平衡二叉树
如果树的节点变成线性结构，那么就会极大的降低我们的查询效率，所以我们必须要有一种方式来保证二叉树节点的平衡，让树的节点高度差不会太大，这个时候就衍生了一些平衡算法，最终我们的二叉树就有像AVL树和红黑树这些新产品，我们也称这些新产品为平衡二叉树，平衡二叉树通常会保证树的左右两边的节点层级相差不会大于2。

平衡二叉树的构建规则：
  1 非叶子节点只能允许最多两个子节点存在。
  2 每一个节点的左边子节点值小于当前节点，右边的子节点值大于当前节点(这里的“值”是基于自己的算法规则而定的，比如hash值)；
  3 通过平衡算法(比如Treap、AVL、红黑树)，保证树左右节点的高度相差不超过2层。

4 B-树(B-tree)
B树和平衡二叉树的不同之处是：B树属于多叉树又名平衡多路查找树(查找路径不止两个)，数据库索引技术里大量使用着B树和B+树的数据结构。

B树的构建规则：
  1 排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
  2 子节点数：树中每个结点最多含有m个孩子(m>=2),若根结点不是叶子结点，则至少有2个孩子，空树除外；
  3 关键字数：枝节点的关键字数量>=ceil(m/2)且<=M-1(注：ceil()是个朝正无穷方向取整的函数);则根结点至少包含一个关键字，空树除外；
  4 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外，也有指向其子节点的指针只不过其指针地址都为null;

B树相对平衡二叉树在节点空间的利用率上进行改进，B树在每个节点保存更多的数据，减少了树的高度，从而提升了查找的性能，在数据库应用中，B树的每个节点存储的数据量大约为4K，这是因为考虑到磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次对磁盘进行IO数据读取时，同一个磁盘块的数据会被一次性读取出来，所以每一次磁盘IO都可以读取到B树中一个节点的全部数据。

磁盘块n 用Dn 表示 k表示关键字 p表示指针
                                |p1 k17 p2 k35 p3|
                              D1 ↙      ↓     ↘
          |p1 k8 p2 k12 p3|      |p1 k6 p2 k30 p3|3    |p1 k65 p2 k87 p3|
        D2 ↙      ↓     ↘     D3        ↓            D4 ↙      ↓      ↘
     |k3 k5|  |k9 k10|  |k13 k15|   |k28 k29|    |k36 k60|  |k75 k79|  |k90 k99|
        D5       D6         D7         D8            D9        D10        D11

假如每个盘块可以正好存放一个B树的结点（正好存放2个文件名）。那么一个BTNODE结点就代表一个盘块，而子树指针就是存放另外一个盘块的地址。
下面，咱们来模拟下查找文件29的过程：
1 根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作 1次】
2 此时内存中有两个文件名17、35和三个存储其他磁盘页面地址的数据。根据算法我们发现：17<29<35，因此我们找到指针p2。
3 根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作 2次】
4 此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现：26<29<30，因此我们找到指针p2。
5 根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作 3次】
6 此时内存中有两个文件名28，29。根据算法我们查找到文件名29，并定位了该文件内存的磁盘地址。
分析上面的过程，发现需要3次磁盘IO操作和3次内存查找操作。关于内存中的文件名查找，由于是一个有序表结构，可以利用折半查找提高效率。至于IO操作是影响整个B树查找效率的决定因素。
当然，如果我们使用平衡二叉树的磁盘存储结构来进行查找，磁盘4次，最多5次，而且文件越多，B树比平衡二叉树所用的磁盘IO操作次数将越少，效率也越高。

一棵含有N个总关键字数的m阶的B树的最大高度是多少?答曰：log_ceil(m/2)(N+1)/2 + 1

插入（insert）操作
插入一个元素时，首先在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素，注意：如果叶子结点空间足够，这里需要向右移动该叶子结点中大于新插入关键字的元素，如果空间满了以致没有足够的空间去添加新的元素，则将该结点进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中（当然，如果父结点空间满了，也同样需要“分裂”操作），而且当结点中关键元素向右移动了，相关的指针也需要向右移。如果在根结点插入新元素，空间满了，则进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。

删除(delete)操作
首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况。
删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于ceil(m/2)-1，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。

5 B+树
B+树是在B树的基础上又一次的改进，其主要对两个方面进行了提升，一方面是查询的稳定性，另外一方面是在数据排序方面更友好。

B+树构建规则
  1 B+树的非叶子节点不保存具体的数据，而只保存关键字的索引，而所有的数据最终都会保存到叶子节点。因为所有数据必须要到叶子节点才能获取到，所以每次数据查询的次数都一样，这样一来B+树的查询速度也就会比较稳定，而B树的查找过程中，不同的关键字查找的次数很有可能都是不同的(有的数据可能在根节点，有的数据可能在最下层的叶节点)，所以在数据库的应用层面，B+树就显得更合适。
  2 B+树叶子节点的关键字从小到大有序排列，左边叶子节点指向右边叶子节点。因为叶子节点有序的，所以B+树对于数据的排序有着更好的支持。
  3 非叶子节点的子节点数=关键字数(另一种为非叶节点的关键字数=子节点数-1)，虽然数据排列结构不一样，但其原理还是一样的。

B+树和B树的对比
  1 B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定。
  2 B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，缓存的命中率也会比B树高。
  3 B+树全节点遍历更快：B+树遍历整棵树只需遍历所有的叶子节点即可，而不需要像B树一样要对每一层进行遍历，这有利于数据库做全表扫描。
  4 B+-tree的磁盘读写代价更低：B+-tree的内部结点没有指向关键字具体信息的指针。因此其内部结点相对B树更小。若把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也越多。相对来说IO读写次数也就降低了。

B树相对于B+树的优点是，若常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字和数据，在查询这种数据检索的时候会要比B+树快。

6 B*树
B*树又是对B+数的再一次改进，在B+树的构建过程中，为了保持树的平衡，节点的合并拆分是比较耗费时间的，所以B*树就是在如何减少构建中节点合并和拆分的次数，从而提升树的数据插入、删除性能。

B*树构建规则
相对于B+树B*的不同之处如下：
  1 首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b*树的初始化个数为(cei(m*2/3))
  2 B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满(因为每个节点都有指向兄弟的指针)，如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；B*树中非根和非叶子结点再增加指向兄弟的指针

B*树 与B+树对比
在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；

B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。

B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。

所以，B*树分配新结点的概率比B+树要低，空间使用率更高。

总结
1 相同思想和策略
从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；

2 不同的方式对树的不断优化
  1 首先，为了保证树的节点均匀分布，所以在二叉树的基础上加上了平衡算法，就有了平衡二叉树。
  2 为了减少树的高度，所以B树一个节点下面可以添加N个子节点，然后每个节点的大小限制在磁盘块容量大小，让节点只需要通过一次IO就能读取到所有数据，通过增加节点存储的数据减少了树的高度，而节点的数据变多并没有让IO次数变多。
  3 B+树在B树的基础上，在查询的稳定性 和排序方面进行了优化，因为B+树所有的数据都会保存到叶子节点，然后所有叶子节点本身是有序的。
  4 B*树为了减少 树在构建过程中节点的拆分、合并次数，所以在每个节点上都保存了旁边节点的指针，在节点需要进行拆分、合并时，优先从旁边节点挪数据，从而减少构建过程中节点拆分、合并的次数，提升了树的构建性能。

B树：有序数组+平衡多叉树；
B+树：有序数组链表+平衡多叉树；
B*树：一棵丰满的B+树。
内存中B+树是没有优势的，但是一到磁盘，B+树的威力就出来了


