



1  编译阶段：define是在编译预处理阶段进行简单的文本替换，const是在编译阶段确定其值
   安全性：define定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全检查；const定义的常量是有类型的，是要进行类型判断的
   内存占用：define定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的内存；const定义常量占用静态存储区域的空间，程序运行过程中只有一份
   调试：define定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const定义的常量是可以进行调试的。
2  内存对齐
3  ++i是左值还是右值，++i和i++哪个效率更高    ++i是左值，因为++i返回的是一个左值没有发生拷贝，所以效率更高。
4  malloc和new的区别
   Malloc/free是标准库函数，new/delete是C++运算符
   Malloc分配内存失败返回空，new失败抛异常
   New返回有类型的指针，malloc返回无类型的指针
   New/delete会调用构造析构函数，malloc/free不会，所以他们无法满足动态对象的要求。
5  未初始化的全局变量和初始化的全局变量放在哪里
   初始化的全局变量存放在数据段，数据段数据静态分配。  未初始化的全局变量存放在BSS（Block Started By Symbol）段,属于静态内存分配
6  extern C关键字  是C++为了兼容C语言所加入的关键字
7  什么是重载、重写、隐藏
   重载：函数名相同，函数参数不同，两个函数在同一作用域
   重写：两个函数分别在子类和父类中，函数名，返回值，参数均相同，函数必须为虚函数
   隐藏：在继承关系中，子类实现了一个和父类名字名字一样的函数。这样子类的函数就把父类的同名函数隐藏了。隐藏只与函数名有关。
8  delete与 delete []区别
   delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。
9  main 函数执行以前，还会执行什么代码  全局对象的构造函数会在main 函数之前执行。
10  内存的分配方式有几种   从静态存储区域分配   在栈上创建  从堆上分配，亦称动态内存分配
11  static和const的使用
12  volatile 关键字的作用？什么时候需要使用volatile 关键字
     volatile关键字告诉编译器其修饰的变量是易变的，它会确保修饰的变量每次读操作都从内存里读取，每次写操作都将值写到内存里。volatile关键字就是给编译器做个提示，告诉编译器不要对修饰的变量做过度的优化，提示编译器该变量的值可能会以其它形式被改变。
     volatile用于读写操作不可以被优化掉的内存，用于特种内存中。
13   了解各种强制类型转换的原理及使用？
     强制类型转换：C语言风格的类型转换，其实就是对内存的不同解析方式。高效便捷，但是没有编译时的类型检查，有可能在调用时出错。
     static_cast：带安全检查的类型转换，用于替代强制类型转换，此转换会在编译时进行类型检查，而强制转换不会。
     dynamic_cast：用于类层次间的上行转换和下行转换（基类必须有虚表）。除了在编译器进行类型安全检查，dynamic_cast还会在运行时进行类型检查。从子类转换为父类时，dynamic_cast和static_cast是一致的，而父类转换为子类的过程中，static_cast是非类型安全的，而dynamic_cast会在转换时做类型安全检查，若不能转换返回Null或抛出异常（在引用类型转换失败时抛出异常）。
     const_cast：仅是将const类型的参数转换为非const型，不做其它转换操作，其它类型转换都不能改变参数的const属性。
     reinterpret_cast：用于进行各种不同类型的指针之间，不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换，转换不检查安全性。其实reinterpret_cast和普通强制类型转换没多大区别，也不是类型安全的，用reinterpret_cast的好处是：（1）将强制类型转换标准化，代码看着顺眼，而且能快速查找到强制类型转换。（2）不改变参数const属性。
14   堆和栈的区别
     栈大小，则么调整   堆是怎么实现的
15   程序的地址空间分布





类
1  多态原理 分类  动态多态利用虚函数实现运行时的多态  静态多态则是通过函数重载  系统编译期间就可以确定程序将要执行哪个函数
2  虚函数是怎么实现的  虚函数表和虚函数指针
3  final delete 什么含义  类中
4  构造函数和析构函数是否能为虚函数
   构造函数不能为虚函数，如果构造函数为虚函数，那么调用构造函数就需要去寻找vptr，但此时vptr还没有完成初始化，导致无法构造对象。
   析构函数可以且经常为虚函数：当我们使用父类指针指向子类时，只会调用父类的析构函数，子类的析构函数不会被调用，容易造成内存泄漏。
5  class与struct的区别  默认继承权限不同：class默认继承的是private继承，struct默认是public继承。
6  空对象指针为什么能调用函数
   在类的初始化的时候，编译器会将它的函数分配到类的外部，这也包括静态成员函数，这样做主要是为了节省内存，
   如果我们在调用类中的的成员函数时没有使用类中的任何成员变量，它不会使用到this指针所以可以正常调用这个函数。
7  空类中有什么函数 默认构造函数、默认拷贝构造函数、默认析构函数、默认赋值运算符 取值运算符、const取值运算符
8  explicit作用   只能用于修饰只有一个参数的类构造函数（有一个例外就是，当除了第一个参数以外的其他参数都有默认值的时候此关键字依然有效）
   作用是该构造函数是显示的，对应的另一个关键字是implicit，意思是隐藏的，类构造函数默认情况下声明为implicit。作用是防止类构造函数的隐式自动转换。
9  成员变量初始化的顺序
   只与定义成员变量的顺序有关  类中const成员常量必须在构造函数初始化列表中初始化。类中static成员变量，只能在类外初始化。
   顺序：基类的静态变量或全局变量，派生类的静态变量或者全局变量，基类的成员变量，派生类的成员变量。
10 C++中空类的大小是多少？ 1字节
11 移动构造和拷贝构造的区别 移动构造函数本质上是基于指针的拷贝，实现对堆区内存所有权的移交，在一些特定场景下，可以减少不必要的拷贝。
12 深拷贝 浅拷贝
13 类中static函数是否能声明为虚函数
    不能，因为类中的static函数是所有类实例化对象所共有的，没有this指针，而虚函数依靠vptr和vtable来处理，vptr是一个指针，在类中的构造函数中生成，
    并且只能通过this指针访问，对于静态成员函数来说，他没有this指针，无法访问vptr，因此static函数无法声明为虚函数
14 哪些函数不能被声明为虚函数？
    构造函数，内联函数（内联函数有实体，在编译时展开，没有this指针），静态成员函数，友元函数（C++不支持友元函数的继承），非类成员函数
15 虚基类  用于解决多继承所带来的“菱形继承”问题 虚继承会使得派生类中只存在一份共同继承的虚基类的实例，从而避免了多个实例之间的冲突。
16  class  A  ；class B；   什么情况B可隐士转换为A


STL
1  vector list 底层数据结构  数组 链表
   vector   push_back  emplace_back
    Push_back时会先调用类的有参构造函数创建一个临时变量，再将这个元素拷贝或者移动到容器之中
    emplace_back则是直接在容器尾部进行构造比push_back少进行一次构造函数调用
   resize和reserve的区别
    使用resize改变的是vector的大小（size），可能会添加或删除元素。
    使用reserve改变的是vector的容量（capacity），不会改变当前元素的数量，仅仅是为了优化内存使用和性能。
  deque：双向队列，连续存储，随机访问。
  stack：栈，不可随机访问，只允许再开头增加/删除元素。
  queue：单向队列，尾部增加，开头删除。
  set：集合，采用红黑树实现，可随机访问。查找、插入、删除时间复杂度为O(logn)。
  map：图，采用红黑树实现，可随机访问。查找、插入、删除时间复杂度为O(logn)。
  hash_set：哈希表，随机访问。查找、插入、删除时间复杂读为O(1)。
2  map和unordered_map
   Map内部实现是一个红黑树，内部所有的元素都是有序的，而hashmap则是内部实现了一个哈希表，内部存储元素是无序的
   哈希碰撞的处理方法
    开放定址法：当遇到哈希冲突时，去寻找一个新的空闲的哈希地址。
    再哈希法：同时构造多个哈希函数，等发生哈希冲突时就使用其他哈希函数知道不发生冲突为止，虽然不易发生聚集，但是增加了计算时间
    链地址法：将所有的哈希地址相同的记录都链接在同一链表中
    建立公共溢出区：将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中
3  map和set的区别和底层实现是什么？map取值的 find，[]，at方法的区别(at有越界检查功能)
     都是红黑树 find查找需要判断返回的结果才知道有没有查询成功;[]不管有没有就是0，如果原先不存在该key，则插入
     at方法则会进行越界检查，这会损失性能，如果存在则返回它的值，如果不存在则抛出异常。
     map 删除元素 防止迭代器失效      erase(it++)
4  迭代器和指针的区别
   迭代器不是指针，是一个模板类，通过重载了指针的一些操作符模拟了指针的一些功能
   迭代器返回的是对象引用而不是对象的值。指针能够指向函数而迭代器不行迭代器只能指向容器
5  线程池怎么实现
6  stl容器是线程安全的吗


C11
1  智能指针 share_ptr weak_ptr(作用)  unique_ptr
2  右值引用  只能绑定到一个临时变量或表达式（将亡值）上
   作用 1 为了支持移动语义  2 完美转发  3.拓展可变参数模板，实现更加灵活的模板编程。
3  左值引用和指针的区别   1 是否初始化 2 是否能改变 3 没有空引用，但有空指针
4  原子操作
5  move底层是怎么实现的  将一个左值引用强制转化为右值引用
6  完美转发的原理     将自己的参数转发给内部调用的其他函数,不仅能转发参数的值，还能保证被转发参数的左、右值属性不变，使用引用折叠的规则，将传递进来的左值以左值传递出来，将传递进来的右值以右值的方式传出。
7  nullptr 为什么替代NULL
8  lamda列表捕获的方式
   引用捕获可能会导致悬挂引用  lambda创建的闭包的生命周期超过了局部变量或者形参的生命期，那么闭包的引用将会空悬。解决方法是对个别参数使用值捕获
9  auto 和decltype 却别
10  std::function：是可调用对象的封装器，可以看做是一个函数对象，用于表示函数这个抽象概念。
    std::bind：使用std::bind可以将可调用对象和参数一起绑定，绑定后的结果使用std::function进行保存，并延迟调用到任何我们需要的时候。


系统
1  进程之间的通信方式  管道  消息队列  共享内存 信号量  套接字
2  线程之间的通信方式  信号量  条件变量  互斥量
3  死锁是什么？死锁产生的条件 产生死锁的四个条件：互斥条件、请求和保持条件、不可剥夺条件、环路等待条件。解决死锁的方法就是破坏上述任意一种条件。
4  如何实现多进程 Linux中C++使用fork  Linux中C++使用fork
5  进程与线程的区别
   进程：是实现某个独立功能的程序，它是操作系统（如windows 系统）进行资源分配和调度的
   线程：是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使⽤用多线程对进⾏行行运算提速。
6  什么是线程安全与线程不安全
     线程安全：多线程访问时，采用了加锁机制，当一个线程访问该类的某一个数据时，会对该数据进行保护，其他线程无法访问，直到该线程读取完，其他线程才可使用，不会出现数据不一致或数据污染。
     线程不安全：不提供数据访问保护，有可能出现先后更改数据造成所得到的数据是脏数据
   什么是上下文切换？
     概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。



实现个memmove方法。
avl树 怎么插入 删除 元素



网络
1  socket中的多路复用
    Select缺点：支持监听的文件描述符fd的数量有限制，最大数量默认是1024个
    Poll优点（相对于select而言）：没有最大文件描述符数量的限制，poll基于链表存储主要解决
    Poll缺点：poll和select一样同样都需要维护一个用来存放文件描述符的数据结构，
      每次poll系统调用时，需要把文件描述符fd从用户态拷贝到内核区，然后poll系统调用返回前，又需要把文件描述符fd集合从内核区拷贝到用户区，这个内存拷贝的系统开销在fd数量很多的时候会很大。
    Epoll优点：和poll一样没有最大文件描述符数量的限制，
      调用epoll_ctl系统调用时拷贝一次要监听的文件描述符数据结构到内核区，在调用epoll_wait的时候不需要再把所有的要监听的文件描述符重复拷贝进内核区，这就解决了select和poll种内存复制开销的问题。
      Epoll水平触发（LT）：对于读操作，只要缓冲区内容不为空，LT模式返回读就绪。对于写操作，只要缓冲区还不满，LT模式会返回写就绪。
      Epoll边缘触发（ET）：对于读操作，当缓冲区由不可读变为可读的时候，有新数据到达时，进程修改了EPOLL_CTL_MOD修改EPOLLIN事件时
      在ET模式下，缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程。
2   tcp连接建立过程  断开过程
3   网络字节序是大端序还是小端序？  大端序。
4   TIME_WAIT 状态有啥用。
5   backlog 作用。





linux
1   fcntl的作用  用于控制打开的文件描述符的一些属性和行为。
    1.复制一个现有的描述符(cmd=F_DUPFD)
    2.获得/设置文件描述符标记（cmd=F_GETFD或F_SETFD）
    3.获取/设置文件状态标记（cmd=F_GETFL或F_SETFL）
    4.获取设置异步IO所有权（cmd=F_GETOWN或F_SETFL）
    5.获取设置记录锁（cmd=F_GETLK或F_SET）
2   Linux中的信号
    僵尸进程产生和消除
3   多任务调度


算法
1   常用的排序算法有哪些？简单描述几个排序算法的优缺点？
    答：选择、冒泡、快速、希尔、归并、堆排等。



QT


线程A读取xml文件，线程B处理xml文件，现在线程B的按钮因该怎么操作
1个QAction 怎么设置 他能显示是点击过
  QAction* act1 = new QAction(widget);
  act1->setCheckable(true)
  QAction->setCheckable(bool checked=false)
  act1->setText("1");
  connect(act1, &QAction::triggered, this, [=](bool checked) {cout << "act1 triggered " << checked << endl; });
  connect(act1, &QAction::toggled, this, [=](bool checked) {cout << "act1 toggled " << checked << endl; });
有3个QAction 怎么设置每次只能有一可被选中
  QActionGroup* group = new QActionGroup(widget);  QActionGroup默认是IsExclusive() == true排他的，单选的。
  group->addAction(act1);
  group->addAction(act2);
  QActionGroup->setExclusive(false)   效果和QActionGroup不存在时是一样的：




信号与槽的同步异步处理？（同步：槽函数处理完毕之后再执行下一步； 异步：信号发送过程不发生阻塞）
为什么 new QWidget 不需要 delete
局部对象的析构顺序应该按照其创建顺序的相反过程
我们也可以手动删除子对象。当子对象析构的时候会发出一个信号destroyed，父对象收到这个信号之后就会从children列表中将它剔除。
{
    QPushButton quit("Quit");
    QWidget window;
    quit.setParent(&window);
}
析构顺序就有了问题。我们看到，在上面的代码中，作为父对象的 window 会首先被析构，因为它是最后一个创建的对象。在析构过程中，它会调用子对象列表中每一个对象的析构函数，也就是说， quit 此时就被析构了。然后，代码继续执行，在 window 析构之后，quit 也会被析构，因为 quit 也是一个局部变量，在超出作用域的时候当然也需要析构。但是，这时候已经是第二次调用 quit 的析构函数了，C++ 不允许调用两次析构函数，因此，程序崩溃了。


Qt多线程同步的几种实现方式
    QT5大模块  QtCore 核心模块 非GUI类  线程 事件等
    QuGui 界面 窗口 按钮 标签 QPainter  QPalette
    QWidgets QuGui子集 可视化ui控件
    QtNetwork 网络
    QtSql 数据库api
QMainForm是从哪里派生的？ QMainWindow::QWidget::QObject
信号和槽的非常强大的机制,使用connect()把信号和槽连接起来并且可以用disconnect()来破坏这种连接。
为了避免从不结束的通知循环，你可以调用blockSignals()临时地阻塞信号。
保护函数connectNotify()和disconnectNotify()使跟踪连接成为可能。
0  show()和exec()的区别
   show显示非模态窗口（不影响用户对其他窗口操作），exec显示模态窗口（阻塞其他窗口，必须在当前窗口操作完成后才能访问其他窗口），open半模态（阻塞其他窗口响应，但不影响后续代码执行）
0   使用MOC系统的方法：
    1. 继承QObject。 2. 类中添加Q_OBJECT宏。

1  互斥量：QMutex
           QMutexLocke  在创建时会自动调用 QMutex 的 lock() 方法，析构时会自动调用 QMutex 的 unlock() 方法。因此使用 QMutexLocker 可以大大减少忘记解锁的情 QReadWriteLock 同样提供了QReadLocker和QWriteLocker
           QSemaphore是QMutex的一般化，它可以保护一定数量的相同资源，而QMutex只能保护一个资源。
           QWaitCondition
   QAtomic
2  Qt信号槽机制的优势和不足 优点：类型安全，松散耦合。缺点：同回调函数相比，运行速度较慢。
   QT的信号可以对应多个槽（但他们的调用顺序随机），也可以多个槽映射一个信号
3  多线程情况下, Qt中的信号槽分别在什么线程中执行, 如何控制
   可以通过connect函数的第五个参数来控制, 信号槽执行时所在的线程
    1)自动连接( Qt::AutoConnection)，默认的连接方式，如果信号与槽，也就是发送者与接受者在同一线程，等同于直接连接；如果发送者与接受者处在不同线程，等同于队列连接Qt::QueuedConnection。。
    2)直接连接(Qt::DirectConnection)，当信号发射时，槽函数立即直接调用。无论槽函数所属对象在哪个线程，槽函数总在发送者所在线程执行，即槽函数和信号发送者在同一线程
    3)队列连接(QueuedConnection)，当控制权回到接受者所在线程的事件循环时，槽函数被调用。槽函数在接受者所在线程执行，即槽函数与信号接受者在同一线程

    信号和槽是用于对象之间的通信的，是Qt的核心。为此Qt引入了一些关键字，他们是slots、signals、emit，这些都不是C++关键字，是Qt特有的，这些关键字会被Qt的moc转换为标准的C++语句。信号槽支持线程间通信，connect函数的第五个参数可以指定信号槽的连接方式：
     1. Qt::AutoConnection：信号的发送者与信号的接收者在同一线程，则默认使用Qt::DirectConnection；如果不在同一线程，则默认  使用Qt::QueuedConnection。
     2. Qt::DirectConnection：信号的发送者与信号的接收者在同一线程中执行，当发出信号后，会马上进入槽函数，看上去就像在信号  发送位置调用了槽函数，在多线程下会比较危险，容易造成崩溃。
     3. Qt::QueuedConnection：信号的发送者与信号的接收者不在同一线程中执行，槽函数运行于信号的接收者线程，当发送信号后，  槽函数不会马上被调用，等待信号的接收者把当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。
     4. Qt::BlockingQueuedConnection：槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。
     5. Qt::UniqueConnection：可以通过按位或（|）与以上四个结合在一起使用。当设置此参数时，当某个信号和槽已经连接时，再进行重复的连接就会失败，也就是避免了重复连接。

4  描述QT中的文件流(QTextStream)和数据流(QDataStream)的区别, 他们都能帮助我们完成一些什么事情.
    QTextStream – 文本流, 操作轻量级数据(int, double, QString), 数据写入文件中之后以文本的方式呈现。
    QDataStream – 数据流, 通过数据流可以操作各种数据类型, 包括类对象, 存储到文件中数据可以还原到内存。
    QTextStream, QDataStream可以操作磁盘文件, 也可以操作内存数据, 通过流对象可以将数据打包到内存, 进行数据的传输.
5  Qt下Tcp通信的整个流程
   QT如果要进行网络编程首先需要在.pro中添加如下代码：QT += network
    服务器端:
    1. 创建用于监听的套接字
    2. 给套接字设置监听
    3. 如果有连接到来, 监听的套接字会发出信号newConnected
    4. 接收连接, 通过nextPendingConnection()函数, 返回一个QTcpSocket类型的套接字对象(用于通信)
    5. 使用用于通信的套接字对象通信
    1>. 发送数据: write
    2>. 接收数据: readAll/read
    客户端:
    1. 创建用于通信的套接字
    2. 连接服务器: connectToHost
    3. 连接成功与服务器通信
    1>. 发送数据: write
    2>. 接收数据: readAll/read
6  描述QT下udp通信的整个流程
    QT下udp通信服务器端和客户端的关系是对等的, 做的处理也是一样的.
    1. 创建套接字对象
    2. 如果需要接收数据, 必须绑定端口
    3. 发送数据: writeDatagram
    4. 接收数据: readDatagram
7   QT下多线程的两种使用方法,
   第一种方法:
   1. 创建一个类从QThread类派生
   2. 在子线程类中重写 run 函数, 将处理操作写入该函数中
   3. 在主线程中创建子线程对象, 启动子线程, 调用start()函数
   第二种方法:
   1. 将业务处理抽象成一个业务类, 在该类中创建一个业务处理函数
   2. 在主线程中创建一QThread类对象
   3. 在主线程中创建一个业务类对象
   4. 将业务类对象移动到子线程中
   5. 在主线程中启动子线程
   6. 通过信号槽的方式, 执行业务类中的业务处理函数
   多线程使用注意事项:
   * 1. 业务对象, 构造的时候不能指定父对象
   * 2. 子线程中不能处理ui窗口(ui相关的类)
   * 3. 子线程中只能处理一些数据相关的操作, 不能涉及窗口

8   Qt的多线程的实现方式有如下四种：
  1. 继承QThread类，重写QThread类的run方法。
    优点：实现简单，可以用信号槽通信。
    缺点：需要自己管理线程的创建释放，频繁地创建释放效率不高。所以适合常驻程序的线程使用。另外因为QThread对象属于父线程，所以对象中的槽函数（如果有的话）其实会在父线程执行。
class Worker : public QThread ...
Worker w;
w.start();
  2. QThread类与MoveToThread，创建对象继承QObject，将对象移动到子线程对象。
   优点：实现简单，使用于比较复杂的业务场景。
   缺点：只能通过信号槽的方式调用业务对象的接口。且不能给此对象指定父对象。
Worker worker;
    QThread thread;

    worker.moveToThread(&thread);

    QObject::connect(&thread, &QThread::started, &worker, &Worker::doWork);         //第一槽函数
    QObject::connect(&thread, &QThread::started, &worker, &Worker::doWork2);        //第二槽函数
    QObject::connect(&worker, &Worker::testdoWork3, &worker, &Worker::doWork3);     //第三槽函数

    //启动线程
    thread.start();

    //调用成员数
    worker.printFunc();

    //发送自定义信号


  3. QThreadPool与QRunnable，继承QRunnable实现run方法完成业务类创建，由QThreadPool启动业务类。
  优点：无需关注线程资源管理，不会频繁创建与释放线程。所以适用需要频繁创建销毁线程的业务场景。
  缺点：没啥缺点。

  4. QtConcurrent::run()直接将任务丢进子线程执行。
    优点：调用简单，无需关注线程资源管理，不会频繁创建与释放线程。
    缺点：没啥缺点。


