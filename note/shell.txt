
https://www.gnu.org/software/bash/manual/bash.html#Redirections    Bash Reference Manual
https://github.com/khwajaimran/Linux/blob/master/Learning%20the%20Bash%20Shell%2C%202nd%20Edition%20-%20Cameron%20Newham%20%26%20Bill%20Rosenblatt.pdf  Learning the Bash Shell, 2nd Edition
https://github.com/Ricky-Wilson/Programming-books/blob/master/PDF/Learning%20the%20bash%20Shell%2C%203rd%20Edition.pdf Learning the bash Shell, 3rd Edition.pdf
http://bbs.chinaunix.net/forum.php?mod=viewthread&tid=218853&page=1&authorid=7696299  shell 十三問
https://blog.csdn.net/trochiluses/article/details/9048539   # 冒号 后面跟 等号，加号，减号，问号的意义






shell命令行快捷键
移动光标
ctrl + a   # 命令行中光标定位行头 同 home 键
ctrl + e   # 命令行中光标定位行尾 同 end 键
Ctrl + b   # 左移一个字符
Ctrl + f   # 右移一个字符
Alt + b    # 左移一个单词  同  Esc + b 同 ctrl + 左键
Alt + f    # 右移一个单词  同  Esc + f 同 ctrl + 右键
Ctrl + xx  # 在命令行首和光标之间移动

编辑命令
Ctrl + h   # 删除光标左边的字符
Ctrl + d   # 删除光标右边的字符(注意 当前命令行没有字符时，会注销系统或结束终端)
ctrl + u   # 删除当前光标左边的所有字符 不含当前光标字符
ctrl + k   # 删除当前光标右边所有字符 含当前光标字符
Ctrl + w   # 删除光标左边的单词(空格隔开) 不含当前光标字符
Alt + d    # 删除光标右面的单词 含当前光标字符 同 Esc + d
Ctrl + y   # 粘贴之前删除的内容到光标后
Ctrl + _   # 回复之前的状态。撤销操作。
Alt + .    # 使用上一条命令的最后一个参数
Ctrl + a + Ctrl + k 或 Ctrl + e + Ctrl + u 或 Ctrl + k + Ctrl + u 组合可删除整行。

Alt + c    # 光标处字符更改为大写字母 并跳到单词后
Alt + u    # 从光标处到单词尾全部更改为全部大写字母 并跳到单词后
Alt + l    # 从光标处到单词尾全部更改为全部小写字母 并跳到单词后
Ctrl + t   # 交换光标处和之前的字符
Alt + t    # 交换光标处和之前的单词
Alt + Backspace       与 Ctrl + w 相同，分隔符有些差别。

控制命令
Ctrl + l   # 清屏 只是向下滚屏 clear命令真正清空
Ctrl + o   # 执行当前命令，并选择上一条命令
Ctrl + s   # 暂停屏幕输出
Ctrl + q   # 恢复屏幕输出
Ctrl + c   # 终止命令
Ctrl + z   # 挂起命令 若重新放回前台 则 fg
Ctrl + d   # 通常代表 键盘输入结束(End Of File, EOF 戒 End OfInput)的意思；也可以用来取代exit
ctrl + m   # Enter
Tab        # 命令补全 和 档案补齐 的功能
shift + Page UP/Page Down # 翻屏

查找历史命令
Ctrl + r   # 逆向搜索命令历史 随输入显示匹配的一条历史命令，Enter执行匹配命令；ESC在命令行显示而不执行
Ctrl + g   # 从历史搜索模式(Ctrl – r)退出
Ctrl + p   # 显示当前命令的上一条历史命令
Ctrl + n   # 显示当前命令的下一条历史命令

Bang (!) 命令
!!         # 执行上一条命令
!blah      # 执行最近的以 blah 开头的命令，如 !ls
!blah:p    # 仅打印最近的以 blah 开头的命令，而不执行
!$         # 上一条命令的最后一个参数，与 Alt + . 相同
!$:p       # 打印输出 !$ 的内容
!*         # 上一条命令的所有参数
!*:p       # 打印输出 !* 的内容
^blah      # 删除上一条命令中的 blah
^blah^foo  # 将上一条命令中的 blah 替换为 foo 并执行
^blah^foo^ # 将上一条命令中所有的 blah 都替换为 foo 并执行
!-n        # 执行倒数第n条命令，!-1 执行上一条命令， !-5 执行倒数第5条命令 
!n         # 执行第n条命令，!681 执行第681条命令

重复执行操作动作
Esc + 操作次数 操作动作    # 指定操作次数，重复执行指定的操作。


history              # 列出目前内存内的所有 history 记忆
history n            # 列出最近n条命令
history -c           # -c 将目前的shell中的所有history内容全部消除
history [-raw] file  # -a 将当前会话的历史行追加到历史文件中，不指定file则默认写入~/.bash_history
  -r 读取历史文件并将内容追加到历史列表中  -w 将当前历史强制写入到历史文件中
history按序号记录，无法记录指令下达时间。
bash登录，系统主动读取~/.bash_history；bash退出，系统将内存记录更新到~/.bash_history，最大存储最后HISTSIZE条
多重登录时，后推出的bash历史记录若大于1000，会覆盖前面先推出的的


shell部分特殊符号
**   # 幂运算   如 let "sus=2**3"  echo $sus -> 8     echo $((3**3)) -> 27
:    # 内置命令 占位符，啥也不做  如在写脚本时，语法结构需要，用:来做占位符，否则执行报错。
       如 if [ "today" == "2011-08-29" ]; then  : ;  else  : ;  fi
-    # 在管线命令中，替代stdout与stdin
       如 tar -cvf - /home/ | tar -xvf - -C /tmp/  # 将/home打包，打包数据传送到stdout -，通过管道作为后面指令的stdin -




stty -a # 终端机的环境设置 列出所有的按键与按键内容
  intr    # ^C(同 ctrl+c) 送出一个 interrupt 中断信号给目前正在 run 的程序
  quit    # ^\ 送出一个 quit 信号给目前正在 run 的程序
  erase   # ^H 向后删除字符
  kill    # ^U 删除在目前指令列上的所有文字
  eof     # ^D End of file 的意思，代表「结束输入」
  start   # ^Q 在某个程序停止后，重新启动它的 output
  stop    # ^S 停止目前屏幕的输出
  susp    # ^Z 送出一个 terminal stop 的喜好给正在 run 的程序
  注 在windows ^S保存，在Linux用vim时，^S 整个画面死锁，因为^S 是stop功能，停止目前屏幕的输出了，恢复是 start，^Q

set [-/+][uvCHhmBx]   # bash 自己的一些终端机设置 -开启选项 +关闭选项
  u # 预设不启用。若启用后，当使用未设置变量时，会显示错误信息
  v # 预设不启用。若启用后，在信息被输出前，会先显示信息的原始内容
  x # 预设不启用。若启用后，在指令被执行前，会显示指令内容(前面有 ++ 符号)
  h # 预设启用。与历史命令有关
  H # 预设启用。与历史命令有关
  m # 预设启用。与工作管理有关
  B # 预设启用。与括号[] 的作用有关
  C # 预设不启用。若使用 > 等，则若文件存在时，该文件不会被覆盖
  如 set -u  echo $undefvar 则报错    set +u  echo $undefvar 不报错
     set -x  echo $PATH   #要输出的指令都会被先打印到屏幕上，前面会多出 + 号
echo $-     # 显示目前所有的 set 设置

/etc/inputrc 与 /etc/DIR_COLORS* 与 /usr/share/terminfo/*   # 也都是与终端机有关的环境配置文件





shell 已经成为UNIX标准的一部分，主要分为两大主流
  sh                        # 由Stephen Bourne开发
    burne shell (sh)
    burne again shell (bash)
  csh
    c shell (csh)           # 由Bill Joy开发
    tc shell (tcsh)
    korn shell (ksh)        # 由David Korn开发


shell都有相同的目的，在UNIX下为用户提供一个界面。为了达到这个目标，shell都提供了相同的基本功能
命令行解释功能 启动程序 输入输出重定向 管道连接 文件名置换 变量维护 环境控制 shell编程


/etc/issue   # 进站信息 在tty1~tty6登录时顶部显示的信息,而不是登录后显示的信息  root身份修改
man issue 中查看到 agetty ，再 man agetty 得到如下的信息
  \d # 本地端时间的日期
  \l # 显示第几个终端机接口
  \m # 显示硬件的等级(i386、i486、i586...)
  \n # 显示主机的网络名称
  \O # 显示 domain name
  \r # 操作系统的版本(相当于 uname -r)
  \t # 显示本地端时间的时间
  \S # 操作系统的名称
  \v # 操作系统的版本

/etc/update-motd.d/ # ubuntu 户登录后会自动加载此目录下的shell脚本，包含欢迎信息 文件名数字开头, 数字越小越先加载
/etc/motd           # centos 欢迎信息


当完成系统登入(login)，就取得一个互动模式的 shell ，也称为 login shell 或 primary shell。
从进程(process)角度来说，在shell下的命令，均是shell所产生的子进程。称之为fork。
执行脚本(shell script)，脚本中的命令则是由另外一个非互动模式的子shell(sub shell)来执行的，
也就是primary shell产生sub shell的进程，sub shell再产生script中所有命令的进程。

Shell 是一个程序，一般都是放在 /bin 或 /usr/bin 目录下
[username@host directory]$    # Linux Shell 默认命令提示符  root下为 #
/etc/shells    # 记录当前 Linux 系统可用的 Shell
echo $SHELL    # 查看系统默认shell

cmd options argument     # 一个标准的shell命令行格式为
指明路径的外部命令 > 命令別名(alias) > 函数(function) > shell內建命令(built-in) > $PATH下的外部命令 # cmd查找优先级

shell 下每个 command 或 function，结束时都会返回父进程一个值，为 return value(RV) 。可用 $? 查看最新的一个。
RV 取值范围 0-255，可有由程式(或 script)的作者自行定义
  script 中，用 exit RV 指定其值，若没指定，在结束时以最后一道命令之 RV 为其值。
  function 中，用 return RV 来代替 exit RV 即可。
RV 的作用，是用来判断行程的退出状态(exit status)，只有两种
  0     为"真"( true )
  非 0  为"假"( false )
  ls exist.file ; $ echo $?   ->  0       # exist.file 存在
  ls no.file    ; $ echo $?   ->  1       # no.file  不存在



Linux命令 多条命令执行 如下是分隔符
1. ;  各命令的执行结果 不会影响其它命令的执行 各个命令都会执行 但不保证每个命令都执行成功 如:ls;pwd
2. && 前面命令执行成功 即 $? == 0 才会去执行后面的命令 如:ls&&pwd
3. || 前面命令执行失败 即 $? != 0 才会去执行后面的命令 如:lsa||pwd  lsa没有这个
4. |  命令行中的为匿名管道 将一个命令输出导向另一个命令输入 流水线处理文本流 如:env|grep LANG


Linux命令 短格式选项和长格式选项
  短格式选项是长格式选项的简写，用一个减号 - 和一个字母表示，例如 ls -l
  长格式选项是完整的英文单词，用两个减号 -- 和一个单词表示，例如 ls --all
  一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外

linux命令行如何换行,一行命令太长,看的不清晰    在行未  \ + ENTER 就可以实现换行


ls -l | while read line ; do echo $line; done    # 多行命令
或
ls -l | while read line
do
 echo $line
done



bash命令 命令解释器
bash [opt] file    # -c 从字符串中读入命令 -i 使用交互式模式 -n 不执行 仅检查脚本是否正确
  -x 显示执行过程详细信息 -v 执行脚本前，先将其内容输出到屏幕上 --help 显示帮助信息 --version 显示版本信息
bash -n File.sh   # 检查脚本语法是否正确
bash -x File.sh   # 执行脚本文件并输出执行过程信息
bash -c -x 'echo " 123 124" | grep 1' # 执行命令 并显示详细过程
+ echo ' 123 124'
+ grep 1
 123 124



Shell 通过 PS1 和 PS2 这两个环境变量来控制提示符的格式
PS1="[\t][\u]\$ "     # 修改PS1则临时生效  添加至.bashrc则永久生效  添加至/etc/profile所有用户生效

# Windows上永久修改GitBash中的相应变量
cd git_install_folder/Git/etc    # 进入安装Git的目录中的etc/目录下。
vim bash.bashrc                  # 在 bash.bashrc 文件的末尾添加如下命令
export PS1='\[\e[36;1m\]jeffxu@Coding:\[\e[33;1m\]\w\[\e[35m\]\$\[\e[0m\]

PS1变量颜色格式 最好将以下的包含在 \[  \] 之内
\e[F;B;Cm     # 字体颜色设置  \e[为颜色提示开始  F为字体颜色 30-37  B为字体背景颜色或控制 C为控制字符
\e[B;F;C;Fm   # B F C顺序随意 因为他们的数值不冲突
\e[0m         # 通知终端将颜色设置重置为默认，否则字体格式会一直延续下去。 同 \e[m
\e[Xm         # 只有一项 X可取值 F B C
\e[F1;F2m     # 2个F值则F2会替换掉F1  对B类似 不过对于控制字符可同时起作用 如 \e[4;5m 下划线加闪烁
a\e]31mx\e[mz # \e] 会忽略掉会面的一切 直到  \e[m 或 \a \r \n 出现 暂称之为中断
a\e]x         # 若没有中断 \e] shell可能会出现不显示输入 排序错乱等现象
a\[z          # \[ 或 \] 只出现了一部分 测试没啥问题 最好能补全

F      B     颜色         C        控制的作用
30     40    黑色         0        使设置的颜色无效(OFF)
31     41    红色         1        高亮显示
32     42    绿色         4        underline
33     43    黄色         5        闪烁
34     44    蓝色         7        反白显示 反显
35     45    紫红         8        不可见  消隐
36     46    青蓝
37     47    白色

\a     铃声字符 同\007
\d     格式为“日 月 年”的日期
\e     ASCII 转义字符 同\033
\h     本地主机名
\H     完全合格的限定域主机名
\j     shell 当前管理的作业数
\1     shell 终端设备名的基本名称
\n     ASCII 换行字符
\r     ASCII 回车
\s     shell 的名称
\t     格式为“小时:分钟:秒”的24小时制的当前时间
\T     格式为“小时:分钟:秒”的12小时制的当前时间
\@     格式为 am/pm 的12小时制的当前时间
\u     当前用户的用户名
\v     bash shell 的版本
\V     bash shell 的发布级别
\w     当前工作目录
\W     当前工作目录的基本名称
\!     该命令的 bash shell 历史数   此命令的历史编号
\#     该命令的命令数量     该命令的命令号
\$     超级用户(root UID=0)，为#；普通用户，为$。
\nnn   对应于八进制值 nnn 的字符
\\     斜杠
\[     开始一个非打印字符序列，可用于将终端控制序列嵌入到提示中 这个序列应该出现在不移动光标的字符序列(如颜色转义序列)之前。它使 bash 能够正确计算自动换行。
\]     结束一个非打印字符序列 这个序列应该出现在非打印字符序列之后。
所有的特殊字符均以反斜杠\开头，目的是与普通字符区分开来。可以在命令提示符中使用以上任何特殊字符的组合。




ANSI 转义码(ANSI Escape code)
https://en.wikipedia.org/wiki/ANSI_escape_code
ANSI 转义序列是命令行终端下用来控制光标位置、字体颜色以及其他终端选项的一项 in-bind signaling 标准。
通常是在文本中嵌入确定的字节序列(符合带内信令的定义)，大部分以 ESC 转义字符和 "[" 字符开始，
终端会把这些字节序列解释为相应的指令，而不是普通的字符编码。
在终端中，ASCII编码中有些字符是不能用来打印显示的，如 '\a' (0x7) 代表响铃，'\n' (0x0A)  代表换行，这些字符被称为控制符。
控制符 '\e' (0x1B)，这个字符代表 ESC ，即键盘上 ESC 按键的作用。ESC 是单词 escape 的缩写，即逃逸的意思。
文本中出现这个转义字符，代表其后方的字符是 ANSI Escape code 编码。

https://stackoverflow.com/questions/8683526/gotoxy-implementation-for-linux-using-printf
printf("%c[%d;%df",0x1B,y,x);  # 设置光标位置 左上角为 1,1 x横坐标 向右递增   y纵坐标向下递增
printf("%c[%d;%dH",0x1B,y,x);  # 测试也可以

ANSI颜色(ANSI color)
ANSI 转义码中有专门控制字符颜色的控制符
构建16257(及更高版本)的Windows 10控制台主机中已经支持ANSI颜色控制了，默认不开启，需要配置注册表如下值
HKEY_CURRENT_USER\Console\VirtualTerminalLevel   设置为 1
否则 需要 下载 ANSICON v1.89 安装个dll
  不介绍Windows程序控制台中使用Windows.h库中的setconsoletextattribute函数
  仅介绍\033控制字符(ESC)的方法。该方法可以直接适用于printf()函数中。
  其中，\033(八进制)即ESC符号，Windows中为\027(十进制)，\x1b(十六进制)
  \033[参数1; 参数2; 参数3 m   # 开始格式 以字母m结尾
  正常的printf中的参数及内容    # 内容格式
  \033[0m                     # 结束格式  如果没有这个则上面设置的一直生效

echo -e "\e[37;44;3;1m测试字符串\e[0m"       # 举例 下面为解释
  -e 启用 echo 命令控制符转码    如 echo -e "a\ndddd"  自动换行
  \e 代表开始ANSI Escape code
  [ 代表转义序列开始符 CSI，Control Sequence Introducer
  37;44;4;1 代表以;分隔的文本样式控制符，37文本前景色为白色，44背景为蓝色，3代表斜体，1代表加粗
  m 代表结束控制符序列
  \e[0m 代表重置文本样式。
  \x1b[0m  \x1B[0m  \033[0m  \u001b[0m  # 等价 因为\e控制符的16进制码为0x1B，8进制码为033

echo -c xxx   表示统计符合条件的行数

 == = ANSI控制码的说明 == =
 \033[0m 关闭所有属性
 \033[1m 设置字体高亮度
 \033[2m 低亮(减弱)显示
 \033[3m 没有任何效果
 \033[4m 下划线
 \033[5m 闪烁          win无效
 \033[6m 没有任何效果
 \033[7m 反显
 \033[8m 消隐          win无效
 \033[30m~\33[37m 设置字体颜色   30:黑 31:红 32:绿 33:黄 34:蓝 35:紫 36:浅蓝 37:白色 38:无 39:无
 \033[40m~\33[47m 设置背景颜色   40:黑 41:红 42:绿 43:黄 44:蓝 45:紫 46:浅蓝 47:白色 48:无 49:无

 单值控制码 不能与其他控制码联用
 \033[nA 光标上移n行
 \033[nB 光标下移n行
 \033[nC 光标右移n行
 \033[nD 光标左移n行
 \033[x;yH设置光标位置                    左上角坐标为1 1
 \033[2J 清屏
 \033[K 清除从光标到行尾的内容
 \033[s 保存光标位置
 \033[u 恢复光标位置
 \033[? 25l 隐藏光标
 \033[? 25h 显示光标


printf("以下是测试文字       \n");          = printf "以下是测试文字       \n"  # bash下 下同
printf("\033[0m默认文字\033[0m\n");
printf("\033[1m高亮文字\033[0m\n");
printf("\033[2m低亮文字\033[0m\n");
printf("\033[3m无效文字\033[0m\n");
printf("\033[4m下划线文字\033[0m\n");
printf("\033[5m闪烁文字(无效)\033[0m\n");           win下无效 linux有效
printf("\033[6m无效文字\033[0m\n");
printf("\033[7m反显文字\033[0m\n");
printf("\033[8m消隐文字(无效)\033[0m\n");           win下无效 linux有效

printf("\n\033[31;1m字体颜色\033[0m测试文字\n");
printf("\033[30m低亮黑色文字\033[0m\t\033[30;1m高亮黑色文字\033[0m\n");
printf("\033[31m低亮红色文字\033[0m\t\033[31;1m高亮红色文字\033[0m\n");
printf("\033[32m低亮绿色文字\033[0m\t\033[32;1m高亮绿色文字\033[0m\n");
printf("\033[33m低亮黄色文字\033[0m\t\033[33;1m高亮黄色文字\033[0m\n");
printf("\033[34m低亮蓝色文字\033[0m\t\033[34;1m高亮蓝色文字\033[0m\n");
printf("\033[35m低亮紫色文字\033[0m\t\033[35;1m高亮紫色文字\033[0m\n");
printf("\033[36m低亮浅蓝文字\033[0m\t\033[36;1m高亮浅蓝文字\033[0m\n");
printf("\033[37m低亮白色文字\033[0m\t\033[37;1m高亮白色文字\033[0m\n");
printf("\033[38m测试文字\033[0m\n");                没有任何效果 原样输出
printf("\033[39m测试文字\033[0m\n");                没有任何效果 原样输出

printf("\n\033[31;1m背景颜色\033[0m测试文字\n");
printf("\033[40m低亮文字黑色背景\033[0m\t\033[40;1m高亮文字黑色背景\033[0m\n");
printf("\033[41m低亮文字红色背景\033[0m\t\033[41;1m高亮文字红色背景\033[0m\n");
printf("\033[42m低亮文字绿色背景\033[0m\t\033[42;1m高亮文字绿色背景\033[0m\n");
printf("\033[43m低亮文字黄色背景\033[0m\t\033[43;1m高亮文字黄色背景\033[0m\n");
printf("\033[44m低亮文字蓝色背景\033[0m\t\033[44;1m高亮文字蓝色背景\033[0m\n");
printf("\033[45m低亮文字紫色背景\033[0m\t\033[45;1m高亮文字紫色背景\033[0m\n");
printf("\033[46m低亮文字浅蓝背景\033[0m\t\033[46;1m高亮文字浅蓝背景\033[0m\n");
printf("\033[47m低亮文字白色背景\033[0m\t\033[47;1m高亮文字白色背景\033[0m\n");
printf("\033[48m测试文字\033[0m\n");                 win没有任何效果 原样输出 linux全部黑色
printf("\033[49m测试文字\033[0m\n");                 没有任何效果 原样输出






echo
默认情况下 最后自动加一个换行 如 echo   # 只有一个空白行
  -e      # 启用反斜线控制字符的转換(參考下表)
  -E      # 关闭反斜线控制字符的转換(预设如此)
  -n      # 取消行末之換行符(同 -e 选项下的 \c 字符)

echo 命令所支持的反斜线控制字符如下表
  \a     # ALERT / BELL (从系统喇叭送出铃声)
  \b     # BACKSPACE ，也就是向左退格键
  \c     # 取消行末之換行符
  \E     # ESCAPE，跳脫键
  \f     # FORMFEED，换页字符
  \n     # NEWLINE，换行字符
  \r     # RETURN，回车键
  \t     # TAB，表格跳位键
  \v     # VERTICAL TAB，垂直表格跳位键
  \n     # ASCII 八进位编码(以 x 开头为十六进位)
  \\     # 反斜线本身
  (表格资料來自 O'Reilly 出版社之 Learning the Bash Shell, 2nd Ed.)

echo "haicoder.net"              # 输出字符并换行
echo -n "haicoder.net"           # 输出字符不换行
echo -e "hello \nhaicoder.net"   # 解析转义字符
echo -e "a\tb\tc\nd\te\tf"       # 使用转义字符
a       b       c
d       e       f
echo -e "\141\011\142\011\143\012\144\011\145\011\146"    #使用 ASCII 八进位编码 同上
echo -e "\x61\x09\x62\x09\x63\x0a\x64\x09\x65\x09\x66"    #使用 ASCII 十六进位编码 同上

echo $RANDOM         # 随机数  为/dev/random 文件的变量  0-32767



printf
printf 不会像 echo 自动添加换行符，我们可以手动添加 \n 无大括号，直接以空格分隔
printf format-string [arguments...]    # 类似于c语言





Linux shell通配符 (wildcards)  GLOB partten
Unix早期有一个/etc/glob文件保存通配符模板,可追溯到 UNIX V6,后来Bash内置了这个功能,但名字被保留。参考 man 7 glob
shell 通配符 / glob 模式通常用来匹配目录以及文件，而不是文本
通配符采有特定的符号，表示特定的含义，特殊符号称为元 meta 字符。
通配符与正则表达式是两个完全不同的东西，通配符只是bash提供的一个功能，正则表达式是一种字符串处理的表达方式。
通配符是由shell处理的(不是由所涉及到命令语句处理的), 它只会出现在命令的“参数”里(不用在命令名称里，也不用在操作符上)。
当shell在“参数”中遇到了通配符时，shell会将其当作路径或文件名去在磁盘上搜寻可能的匹配，若符合要求的匹配存在，
则进行代换(路径扩展)；否则就将该通配符作为一个普通字符传递给“命令”，然后再由命令进行处理。
总之，通配符实际上就是一种shell实现的路径扩展功能。
在通配符被处理后, shell会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。

*               # 匹配 0 或多个字符  如 a*b a与b之间可有任意长度的任意字符 或没有 如aabcb axyzb a012b ab
?               # 匹配任意一个字符   如 a?b a与b之间必须也只能有一个任意字符  如aab abb acb a0b
~               # 当前用户家目录     如 ~xingmu  用户xingmu家目录
. or ~+         # 当前工作目录
~-              # 前一个工作目录
[list]          # 匹配 list 中的任意单一字符    如 a[xyz]b a与b之间必须也只能有一个字符 但只能是x或y或z 如axb ayb azb
[^list]         # 匹配除 list 外的任意单一字符  如 a[!0-9]b a与b之间必须也只能有一个字符 但不能是阿拉伯数字 如axb aab a-b
[!list]         # 同[^list]          如 echo report[!1-3].txt
[start-end]     # 表示一个连续的范围  如 a[0-9]b 0与9之间必须也只能有一个字符 如a0b a1b... a9b
[!start-end]    # 匹配连续范围外的任意单个字符 echo report[!1-3].txt -> report4.txt report5.txt
{str1,str2}     # 匹配大括号里面的所有模式 模式之间使用逗号分隔  如 echo d{a,e,i,u,o}g -> dag deg dig dug dog
  1 {...}与[...]有一个很重要的区别。如果匹配的文件不存在，[...]会失去模式的功能，变成一个单纯的字符串，而{...}依然可以展开。
    ls [ab].txt  -> ls: [ab].txt: No such file or directory # 不存在 a.txt 和 b.txt  [ab].txt就会变成一个普通的文件名
    ls {a,b}.txt -> ls: a.txt: No such file or directory ls: b.txt: No such file or directory  {a,b}.txt可以照样展开
  2 大括号可以嵌套   # 如 echo {j{p,pe}g,png} -> jpg jpeg png
  3 大括号也可以与其他模式联用  先进行大括号扩展，然后进行*扩展  # 如 echo {cat,d*} -> cat dawg dg dig dog doug dug
{start..end}    # 会匹配连续范围的字符
  1 echo {11..15} -> 11 12 13 14 15     echo d{a..d}g -> dag dbg dcg ddg
  2 echo {a1..3c} -> {a1..3c}   # 遇到无法解释的扩展，模式会原样输出
  3 echo .{mp{3..4},m4{a,b,p,v}} -> .mp3 .mp4 .m4a .m4b .m4p .m4v  # 与逗号联用，可以写出复杂的模式
[[:digit:]]     # 任意数字，相当于0-9
[[:lower:]]     # 任意小写字母,表示 a-z
[[:upper:]]     # 任意大写字母,表示 A-Z
[[:alpha:]]     # 任意大小写字母
[[:alnum:]]     # 任意数字或字母
[[:blank:]]     # 水平空白字符
[[:space:]]     # 水平或垂直空白字符
[[:punct:]]     # 标点符号
[[:print:]]     # 可打印字符
[[:cntrl:]]     # 控制(非打印)字符
[[:graph:]]     # 图形字符
[[:xdigit:]]    # 十六进制字符
[^[:upper:]]    # 非大写字符之外的单个字符；
[^0-9]          # 非数字的单个字符
[^[:alnum:]]    # 非数字和字母的单个字符

注意
  1 ls a*.txt -> ab.txt  # Bash命令里面有通配符 先通配符扩展 后执行命令  Bash先将a*.txt扩展成ab.txt 然后再执行ls ab.txt
  2 echo r* -> r* (不存在 r 开头的文件名) # 若通配符不匹配 会原样输出  特例 这条规则对{...}不适用
  3 ls */*.txt # 所有通配符只匹配单层路径 不能跨目录匹配 即无法匹配子目录里面的文件 ?或*这样的通配符不能匹配路径分隔符/
  4 touch 'fo*' > fo* # 单引号会转义所有字符 且单引号中间不允许再出现单引号 双引号允许出现特定的 shell 元字符 $ ` \
  5 在使用花括号 {} 的时候 里面的单个字符串需要使用单引号或者双引号括住 否则就会视为多个的单个字符





Linux shell 元字符 meta
在使用通配符时如果没有进行转义可能就会被辨识为元字符
IFS     # 默认由 space tab enter 三者之一/多组成 (Internal Field Seperator)
CR      # 由 enter 产生
=       # 设定变量   变量名=值  注意无空格
$       # 作变量或运算替换   $变量名 推荐${变量名} $0...$9 代表shell文件的參數
>       # 重导向标准输出  *
<       # 重导向标准输入  *
|       # 命令管线  *
&       # 重导向文件描述符，或将命令静默执行  *   如 2>&1     cmd &
( )     # 将其内的命令置于 nested subshell 执行，或用于运算或命令替换  *       如 (pwd)  $(pwd)=`pwd`
{ }     # 将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围  如 { pwd; }  ${PATH}
;       # 在前一个命令结束时，而忽略其返回值，继续执行下一个命令 命令結束符 *
&&      # 在前一个命令结束时，若返回值为 true，继续执行下一个命令  *
||      # 在前一个命令结束时，若返回值为 false，继续执行下一个命令  *
!       # 执行 history 中的命令  *

* 标记的都是作用在命令名直接。可以看到shell 元字符，基本是作用在命令上面，用作多命令分割(或者参数分割)。
因此看到与通配符有相同的字符，但是实际上作用范围不同。所以不会出现混淆。
从技术细节来看，shell 根据 IFS 將 command line 所输入的文字分解为"字段"(word)。
然后再针对特殊字符(meta)先作处理，最后再重组整行 command line 。

man bash
       metacharacter
              A character that, when unquoted, separates words.  One of the following:
              |  & ; ( ) < > space tab newline
       control operator
              A token that performs a control function.  It is one of the following symbols:
              || & && ; ;; ;& ;;& ( ) | |& <newline>

'2>&1|' 简写为 '|&' ，将标准错误输出(stderr)隐式重定向到标准输出(stdout)是在命令指定的任何重定向之后执行的。

case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac 语法中
;; 相当于break 即第一次匹配之后就退出整个case
;& 替代 ;; 表示  在第一次匹配之后 后面的条件不管匹配与否 执行里面的语句
;;& 替代 ;; 表示 在第一次匹配之后 后面的条件若匹配 则执行里面的语句
举例如下
case b in a) echo a;; b) echo b;; a) echo a2;; b) echo b2 ;; *) echo no ;; esac   # b
case b in a) echo a;& b) echo b;& a) echo a2;& b) echo b2 ;& *) echo no ;& esac   # b a2 b2 no
case b in a) echo a;;& b) echo b;;& a) echo a2;;& b) echo b2 ;;& *) echo no ;;& esac # b b2 no
case b in a) echo a;;& b) echo b;;& a) echo a2;;& b) echo b2 ;; *) echo no ;;& esac # b b2
case b in a) echo a;;& b) echo b;;& a) echo a2;; b) echo b2 ;; *) echo no ;;& esac # b b2


元字符优先级
1 重定向属于各个命令
2 管道连接两个命令
3 && || ; 优先级相同
4 小括号、大括号可以将命令组合成一个整体，但它们有特殊意义
  4.1 小括号使得命令在子 Shell 环境下执行
  4.2 大括号使得命令在当前 Shell 环境下执行

# 重定向属于第二个命令，不属于第一个命令或命令整体
echo haha | echo hhh >/tmp/a.log
lsdasd | echo hehe 2>/dev/null   # 仍然会报错
lsdasd 2>/dev/null| echo hehe    # 不会报错





shell转义符
There are three quoting mechanisms: the escape character, single quotes, and double quotes.  # man bash
想让通配符，或者元字符变成普通字符。就需要用到引用(quoting)了。 shell提供的引用有三种
''       # 硬转义(hard quote) 内部所有的shell元字符、通配符都会被关掉。注意不允许出现'(单引号)，即使使用了反斜线转义也不允许。
""       # 软转义(soft quote) 内部只允许出现特定的shell元字符 ($,`,\)  $参数代换 `命令代替 \转义单个字符，如果开启了"!"引用历史命令时，则感叹号也除外。
\        # 反斜杠 (escape) 去除其后紧跟的元字符或通配符的特殊意义。

ls \*.txt   -> ls: 无法访问 *.txt: 没有那个文件或目录
ls '*.txt'  -> ls: 无法访问 *.txt: 没有那个文件或目录
ls 'a.txt'  -> a.txt
ls *.txt    -> a.txt  b.txt

a='1      # 同 "   由于<enter>被置于hard quote中 因此不再作为CR字符处理 这里的 <enter> 只是一个换行符(new-line)而已
> 2       # 由于 command line没有 CR 字符 因此进入第二个shell prompt (PS2，以 > 表示) command line 并不会结束
> 3'      # 第三行的<enter>不在hard quote里面 因此并没有被关闭 此时command line 碰到 CR 字符 于是结束 交给 shell 处理
echo $a   # 由于变量没在soft quote中 因此当变量替换完成后并作为命令行重组时 <enter>会被解释为 IFS 而不是 New Line 字符
1 2 3
echo "$a" # 同echo '$a'
1
2
3

A=B\      # 第一个 <enter> 跟第二个 <enter> 均被 escape 字符关闭了，因此也不作为 CR 來处理
> C\
>         # 第三个 <enter> 由于沒被跳脫，因此作为 CR 结束 command line
$ echo $A
BC

一个<enter> 鍵所产生的字符就有可能是
CR
IFS
NL(New Line)
FF(Form Feed)
NULL


关于转义字符 \
在双引号中即可变普通字符的特殊字符  空格 * # 换行符
  空格 '\ `  # 这是转义空格。如果路径中包含空格，那么使用 \ 转义可以避免路径被分割成 Shell 的两个参数。
  星号 '*`   # 单独使用 * 表示当前路径下枚举的所有文件或文件夹。如希望保持 * 的原意，要将其包裹在引号内，或者使用转义 \*。
  井号 #     # 表示注释。
  换行符     # 在引号中，也可以直接换行。这样换行符就是字符串的一部分。
在双引号中依然被 Shell 解释的特殊字符  " $ ` \  若要当成普通字符则需要转义  \" \$ \` \\
任意字符也可以使用 \ 转义，虽然没用，但也是一个特性  echo \H\e\l\l\o\ \"\W\a\l\t\e\r\l\v\"  -> Hello "Walterlv"


grep -n \. file     # 不能识别file中 .
grep -n \\. file    # 可以识别file中 .
grep -n '.' file    # 不能识别file中 .
grep -n '\.' file   # 可以识别file中 .
grep "\\\\" file    # shell把四个\,转义成2个\传递给grep，grep再把2个\转义成一个\查找
grep '\\' file      # shell没转义，直接把2个\传递给grep，grep再把2个\转义成一个\查找
linux中的单引号和双引号的确对转义字符有不同的分别，但前提是转义系统保留字，例如:$,>,<等(系统保留字)
grep天生支持正则表达式，所以在grep看来，它的转义字符包括两部分，一部分就是系统保留字，另一部分就是正则表达式的转义字符.
如^是正则转义字符，但由于它非系统保留字，所以单引号和双引号对它都是一样的，但是不加引号就不起作用(貌似不加也没事)。
对于系统保留字，grep依然满足不同引号的不同用法，如 "$boy"和'$boy'那可就不一样；但对正则表达式的转义字符，则对引号不敏感。
因此这告诉我们，以后将系统保留字与正则表达式混用时，正则表达式尽量按照规则来写
如果grep搜索内容中有空格，则需要使用单引号或者双引号把搜素内容引起来！建议使用grep时都老老实实的多输入两个单引号。






shell中$后加引号有什么用($"string"和$'string')
http://www.cnblogs.com/f-ck-need-u/p/7048359.html

1.如果没有特殊定制bash环境或有特殊需求，$"string"和"string"是完全等价的，使用$""只是为了保证本地化。
man bash关于$""的解释
  A  double-quoted  string  preceded by a dollar sign ($"string") will cause the string to be translated
  according to the current locale.  If the current locale is C or POSIX, the dollar sign is ignored.
  If the string is translated and replaced, the replacement is double-quoted.
2.$后接单引号的$'string'，这在bash中被特殊对待，会将某些反斜线序列(如\n，\t，\"，\'等)继续转义，
而不认为它是字面符号(如果没有$符号，单引号会强制将string翻译为字面符号，包括反斜线)。

echo 'a\nb'
a\nb

echo $'a\nb'
a
b

man bash里关于$'的说明
Words of the form $'string' are treated specially.  The word expands to string, with backslash-escaped
characters replaced as specified  by  the ANSI C standard.  Backslash escape sequences, if present,
are decoded as follows:
  \a     alert (bell)
  \b     backspace
  \e
  \E     an escape character
  \f     form feed
  \n     new line
  \r     carriage return
  \t     horizontal tab
  \v     vertical tab
  \\     backslash
  \'     single quote
  \"     double quote
  \nnn   the eight-bit character whose value is the octal value nnn (one to three digits)
  \xHH   the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)
  \uHHHH the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits)
  \UHHHHHHHH
         the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits)
  \cx    a control-x character








shell命令执行过程概述
var='hello world'
echo -e $var $(((2+3)/5))

1 读取命令行
2 解析命令行   变量$var,替换成值 hello world;数学运算,替换成值 1,替换后得到 echo -e hello world 1 命令行
3 命令行解析完成后，调用命令
  3.1 创建一个子 shell 进程，父 shell 进程被阻塞，它要等待子进程的退出，并且此时子进程获得终端控制权
  3.2 在子 shell 进程中通过 exec 加载磁盘中的 echo 命令
  3.3 exec 加载命令时，会搜索 echo 命令，然后调用它，于是替换子 shell 进程并得到 echo 进程
4 echo 进程开始执行，它要识别选项和参数，于是输出 hello world 1 到终端
5 echo 进程退出，并记录一个退出状态码
6 回到 shell 进程，shell 进程读取子进程的退出状态码，echo 子进程完全消失，shell 进程准备执行下一个命令





shell命令执行过程详细
0  read command
1  split into tokens         # 用meta来分割字符串   复杂命令分解成简单命令
2  check 1st token           # 检查有无语法错误
3  check 1st                 # expand alias   别名扩展
4  brace expansion           # 大括号扩展                  ——
5  tilde expansion           # ~ 解析                      ↑
6  parameter expansion       # 变量替换    ——
7  command substitution      # 命令替换   双引号          单引号
8  arithmetic substitution   # 算术扩展    ——
9  word spliting             # 单词拆分                     ↓
10 pathname expansion        # wildcard 匹配  文件名扩展    ——
11 command lookup            # 搜索命令  funtions,built-in command,executable file
12 run command               # 执行命令 make argument into next command

双引号扩展包括6-8项，单引号为4-10项，无论单双引号转义符告诉各个命令自身内部是一体的，但其本身并不是命令中文本的一部分。


            ————————————————————————————————eval命令—————————————————————————————————————————
            ↓                                                                               |
  如  |-> 复杂命令行分解   无 | --->   大括号扩展                                              |
  果  |     ↓             引 |            ↓                                                  |
  是  |   简单命令结构     号 |        波浪号扩展                                              |
  别  |     ↓                |            ↓                                                  |
  名  |-- 别名扩展            | --->   变量替换                                               |
            |             双 |            ↓                                                  |
            |             引 |        算数扩展         --------> 引号去除 ---> 搜索命令 ---> 执行命令
            ↓             号 |            ↓           |            ↑
           根据引用决定扩展 ---        命令替换         |            |
            |                             ↓           |            |
            |                         单词拆分         |            |
            |                             ↓           |            |
            |                         文件名扩展 ------             |
            |-------------------------------------------------------
                      单引号


举例
name="longshuai"
a=24
touch ~/i{a,b}.sh
echo -e "some files:" ~/i* "\nThe date:$(date +%F)\n$name's age is $((a+4))" >/tmp/a.log
/tmp/a.log中的结果为
some files: /root/ia.sh /root/ib.sh
The date:2017-08-14
longshuai's age is 28

1 读取命令行

2 解析引用并分割命令行为各个单词(token)。其中重定向所在的token会被保存下来，直到步骤5结束后才处理，如进行扩展、截断文件等。
  反斜线引用、单引号引用和双引号引用  # shell中3种引用方式
  反斜线转义     使得元字符变为普通的字面字符。但只能对反斜线后一个字符进行转义。
  单引号引用     单引号内的所有字符全部变为字面符号符号。但单引号内不能再使用单引号，即使使用了反斜线转义也不允许。
  双引号引用     使双引号内所有字符变为字面符号，但"\"、"$"、"`"除外，如果开启了"!"引用历史命令时，则感叹号也除外。
解析引用后，将命令行进行单词分割。分割单个命令和命令列表，分隔符包括空格、tab、分号、管道符号、&、&&、||、重定向符号、圆括号等。
于是上述命令分割为以下几个token        #表示分割
echo # -e # "some files:" # ~/i* # "\nThe date:$(date +%F)\n$name's age is $((a+4))" # >/tmp/a.log
(虽然换行符是shell划分命令行token的元字符，但是shell并不认识这里的\n，shell只认识我们直接手动敲下的回车键，
而这里\n是由echo -e识别的换行符，这里的\n不是shell解析命令行时划分token的换行符，\n被认为是双引号包围的token的一部分)
如果分割时发现了管道符号，或者是命令列表等组合了多个命令的情况，则每个命令都的token都相互独立。

3 检查命令行结构。检查是否有命令列表、是否有shell编程结构的命令，如if、for/while/select/until等保留关键字，需要特殊处理。

4 对第一个token别名扩展。是别名，则回到2再次进行token分解。是函数，则执行函数体中的复合命令。既是别名，又是函数，优先别名。

5 进行各种扩展。扩展顺序为大括号扩展；波浪号扩展；参数、变量、算术扩展和命令替换，进程替换(如系统支持)；单词拆分；文件名扩展。
没有任何引号时将从头到尾全部扩展，使用单引号时将完全不会进行任何扩展，使用双引号时将从变量替换开始继续扩展。
  5.1 大括号扩展   如/tmp/{a,b}.log扩展为/tmp/a.log和/tmp/b.log。
  5.2 波浪号扩展   扩展为家目录。如root用户下的~/.ssh扩展为/root/.ssh。
  5.3 变量扩展   即操作和替换变量值。如$a替换为它的值24， ${name:-longshuai} 替换为longshuai。
  5.4 算术扩展   计算算术值，并将计算结果替换到对应位置处。例如$((a+4))替换为28。
  5.5 命令替换   此过程将执行命令替换中的命令，并将结果替换到token的对应位置处。
  5.6 进程替换   将进程的执行结果替换到对应位置。类似于命令替换。
    替换格式为"<(cmd_list)"和">(cmd_list)"，例如 cat <(cat /etc/hosts) 。redhat系列应该都支持进程替换。
经过以上几种扩展后，得到如下结果
echo # -e # "some files:" # ~/i*     "\nThe date:$(date +%F)\n$name's age is $((a+4))" # >/tmp/a.log
                  波浪号替换 ↓                命令替换 ↓  变量替换 ↓       算术扩展 ↓
echo # -e # "some files:" # /root/i* "\nThe date:2023-08-01\nloangshuai's age is 28" # >/tmp/a.log
  5.7 单词拆分   扫描变量扩展、命令替换和算术扩展的结果，对非引号内的结果按照$IFS的值对这些结果进行单词分割。
    注意，如果没有进行扩展，或者扩展结果使用引号包围了，则不会进行此步的单词拆分。
    默认情况下，$IFS值为" \t\n"，所以扩展结果中每遇到空格、制表符、换行符都将被分割为两个单词。
    这一步很容易犯错，典型的是test命令。如变量 name="Ma longshuai" ，则 test $name == "longshuai" 将报错，
      因为变量扩展后该语句变为 test Ma longshuai == "longshuai" ，由于是变量替换，所以随后进行单词拆分，
      使得Ma和longshuai被拆分为两个单词，但实际上它们共同组成变量name的值。
    为了正确操作变量替换和命令替换，尽量将它们使用引号包围。如 test "$name" == "longshuai" ，这时将不会进行单词拆分。
  5.8 文件名扩展   对每个token进行搜索，将搜索"*"、"?"和"["符号，搜索到了将进行文件名扩展。
    如将上面的"/root/i*"扩展为"/root/ia.sh /root/ib.sh"。

6 引号去除。经过上面的过程，该扩展的都扩展了，不需要的引号在此步就可以去掉了。
所以得到如下结果。
echo # -e # "some files:" # /root/i* # "\nThe date:2023-08-01\nlongshuai's age is 28" # >/tmp/a.log
                                ↓
                            /root/ia.sh
                            /root/ib.sh

7 搜索和执行命令。
单词分割后，复杂的命令行将由各个简单命令结构组成。于是可以搜索每个简单命令结构的第一个token中的命令，
同时还带有一系列命令选项。例如上面的"echo"和"-e"。
如果命令中不含任何斜杠
  7.1 则先判断是否有此名称的shell function存在，如果有则调用它，否则进行下一步搜索。
  7.2 判断该命令是否为bash内置命令，如果是则执行它，否则进行下一步搜索。
  7.3 从$PATH的路径下搜索该命令，如果搜索到了，则执行，否则报错。
如果命令中包含一个或多个斜杠，则进行相对路径扩展、绝对路径查找，找到了则执行，否则报错。

8 返回退出状态码。



另一种分析
1 读取命令行，并将读取的字符内容交给词法解析器

2 词法解析阶段
  2.1 解析引用 (即识别双引号、单引号和反斜线)，并根据空白符号和 bash 元字符，将读取的内容划分成 token (Shell也叫word)
    划分 token 的元字符有       | & ; ( ) < > space tab
    解析引用是为了防止被引用的整体部分被分割成多个 token
    如 echo "ls|cat" 不会因为里面有竖线就将引号包围的部分划分成多个 token
  2.2 根据控制元字符，将复杂命令结构划分成简单命令结构  即将多个或复杂的命令行，划分成简单的一个一个命令
    控制元字符有       || & && ; ;; ( ) | |& <newline>
  2.3 检查第一个 token
    如果第一个 token 是别名，则进行别名扩展
      别名替换本不该是词法解析阶段完成的，但涉及 Bash 自身语法支持，别名扩展会直接影响命令行结构，故词法解析阶段处理它才更合理
    如果第一个 token 是带有等号 = 且等号前的字符符合变量命名规范，则本条命令是一个变量赋值
    如果是 shell 函数、shell 内置命令、shell 保留关键字，则做相应处理
因为上面的命令行中，没有复杂命令结构，只是单个 echo 命令行，而且第一个 token 没有别名，所以，划分 token 后的结果如下
echo -e "some files:" ~/i* "\nThe date:$(date +%F)\n$name's age is $((a+4))" >/tmp/a.log
                               ↓
echo # -e # "some files:" # ~/i* # "\nThe date:$(date +%F)\n$name's age is $((a+4))" # >/tmp/a.log

3 word (token) 扩展阶段 (各种 Shell 扩展和替换)
称为 word 扩展是因为下面这些操作都可能会改变 word 的数量。
所谓扩展或替换，指的是 Shell 会分析各个 token 中的某些特殊符号，并进行对应的值替换。
按照下面的先后顺序进行各种扩展行为
  大括号扩展
  波浪号扩展
  变量替换
  算术替换
  命令替换
  单词拆分
  引号移除
此外，对于支持命名管道的 Shell，还支持进程替换。因为进程替换中的命令是异步执行的，而且它不会将执行结果替换到命令行中，
而是以虚拟文件的方式作为命令的标准输入或标准输出，所以不要考虑进程替换在哪个阶段执行，这没有意义。
尽管官方手册说，进程替换可能在波浪号扩展、变量替换、算术扩展、命令替换这四个阶段的任何一个阶段执行。

  3.1 大括号扩展
    如 echo hey{1..3} 在这一阶段替换后变成 echo hey1 hey2 hey3
  3.2 波浪号扩展，~ 扩展成家目录，此外还有 ~+、~- 等也是波浪号扩展
    如 对于 root 用户 ls ~/.ssh ~/.bashrc ->  ls /root/.ssh /root/.bashrc
  3.3 变量替换，将变量的值替换到变量引用位置处，此外还有各种变量操作也是变量扩展
    如 ls /$USER -> ls /root   echo ${#USER} -> echo 4
  3.4 算术替换，即将算术运算的结果替换到算术表达式位置处
  3.5 命令替换，即执行命令替换中的命令，并将命令的标准输出替换在命令替换位置处
    如，echo $(hostname -I) -> echo 192.168.100.11
    如果命令替换的命令有多行，则默认会压缩成单个空格。可使用双引号保护命令替换的结果   *****1
    如 echo $(echo -e 'a\nb') -> echo a b   echo "$(echo -e 'a\nb')" -> echo $'a\nb'
  3.6 单词拆分 (word splitting)
    重新扫描变量替换、算术扩展、命令替换后的结果，如果这三种替换是使用双引号包围的，则不会拆分开，
      如果它们没有使用双引号包围，则  根据 IFS 变量的值再次对它们划分单词             *****2
    如 n="name age";test $n -eq "name age" 语法报错，因为单词拆分后得到 test name age -eq "name age"，
      但如果加上双  引号包围 "$n"，则得到 test "name age" -eq "name age"
    如果没有变量替换、算术扩展、命令替换，则不会执行单词拆分
  3.7 路径名扩展，也即通配符扩展 通配符包括 * [] ?
    如 /root 下有 ia.sh 和 ib.sh 文件，ls /root/i*.sh -> ls /root/ia.sh /root/ib.sh
  3.8 引号去除，即移除为了保护 Shell 解析的那一层引号
    命令在开始执行之前，所有不需要的引号 (即 Shell 层次的引号) 都会被移除
    如 cat "/proc/self/cmdline" -> cat /proc/self/cmdline

整个扩展过程如下所示
echo -e "some files:" ~/i* "\nThe date:$(date +%F)\n$name's age is $((a+4))" >/tmp/a.log
                               ↓  划分tocken 命令行分解 别名扩展
echo # -e # "some files:" # ~/i* # "\nThe date:$(date +%F)\n$name's age is $((a+4))" # >/tmp/a.log
                  波浪号替换 ↓                命令替换 ↓  变量替换 ↓       算术扩展 ↓
echo # -e # "some files:" # /root/i* "\nThe date:2023-08-01\nlongshuai's age is 28" # >/tmp/a.log
             | 引号移除           ↓  路径扩展
             |              /root/ia.sh
             ↓              /root/ib.sh
echo # -e # some files: # /root/i* \nThe date:2023-08-01\nlongshuai's age is 28 # >/tmp/a.log


关于 word splitting 和路径扩展，有一个注意事项

touch "aa aaa.txt"
touch "bb bbb.txt"
for i in *.txt;do
  echo $i
done

因为在单词分割时，*.txt 还没有扩展，等到路径扩展时，aa aaa.txt 自然会被作为一个元素整体。
而下面代码是有问题的，因为命令替换在单词分割之前

touch "aa aaa.txt"
touch "bb bbb.txt"
for i in $(ls *.txt);do
  echo $i
done

改进方式是修改 IFS 的值
(IFS=$'\n';for i in $(ls *.txt);do echo $i;done)

当 Shell 处理完各种 Shell 扩展之后，意味着 Shell 的解析完成了，接下来准备让命令运行起来。

4 搜索命令并执行
Shell 首先判断第一个 token (即命令):
  4.1 如果命令中不含任何斜杠
    先判断是否有此名称的 shell function 存在，如果有则调用它，否则进行下一步搜索
    判断该命令是否为 bash 内置命令，如果是则执行它，如果不是，则当作外部命令处理
  4.2. 如果命令中包含一个或多个斜杠，则当作外部命令处理
    4.2.1 Shell 创建(fork)一个子 shell 进程，然后父 Shell 进程自身进入阻塞并等待子进程终止，同时会让出终端的控制权
    4.2.2 子 Shell 进程调用(exec)外部命令并替换当前子 Shell 进程
      exec调用外部命令时，搜索，如果 token 中包含斜线，则从相对路径或绝对路径中查找，否则从 $PATH 中搜索，找不到，则报错
      替换子 Shell 进程后，就不再称为子 Shell 进程，而称之为对应命令的进程 (比如 echo 进程)
命令退出后回到父 Shell，父 Shell 去获取命令退出状态码并赋值给变量 $?，然后就可以执行下一条命令。



eval命令
eval command arguments   # 语法格式
正常情况下，当搜索到命令时将会执行命令，但如果搜索到的命令为eval时，则处理方式有所不同。
按照前文所述shell解析过程，将最终得到eval command和一系列扩展后的选项、参数，当搜索命令时，
搜索到的结果为eval命令，于是eval命令将除了eval命令(以及eval的选项)的所有token再次传递给shell进行二次解析。
但重定向所在token除外，因为重定向token早已被shell保存下来，所以不会再次截断文件。
也就是说，"command arguments"被当作eval命令的参数，被传递给shell进行解析、执行。

示例
a=24;name='long$a'     # 单引号 禁止$a被扩展
echo $name             # 结果为"long$a"
eval echo $name        # long24
首先shell按照正常过程解析，在变量替换时由于使用了单引号，所以$name第一次变量替换的结果为"long$a"，
直到命令搜索时发现搜索到的命令是eval命令，执行eval命令，该命令将其参数 echo long$a 再次传递给shell，
相当于在标准输入中输入了 echo long$a ，于是shell进行二次解析，这次的变量替换将$a替换为24，
最后搜索命令发现是echo命令，于是最终得到"long24"。

eval更多的用法是间接变量$$var，bash中第一个$前要加上反斜线，即 \$$var，防止第一次shell解析时"$$"被当作特殊变量扩展。
a=b ; b=haha ; eval echo \$$a    # 输出 haha





基本正则 grep
1 基本元字符
.   # 匹配任意单个字符                      如 grep "r..t" /etc/passwd 匹配r和t中间有两个任意字符
[]  # 匹配指定范围内的任意单个字符           如 grep "[0-9]" /etc/inittab  匹配0到9中任意一个数字
[^] # 匹配指定范围外的任意单个字符           如 grep "[^0-9]" file  匹配数字之外的
2 次数匹配 注意       grep默认工作在贪婪模式下，即尽可能长的匹配
*   # 匹配其前面的字符任意次   如 ooo*匹配oo、ooo等，不能写oo*，*作用于第二个o   [0-9][0-9]* 包含任意数字
.*  # 表示匹配任意字符任意长度(含0次)         如 grep "a.*b" test.txt
\?  # 匹配其前面的字符1次或0次               如 grep "a\?b" test1
\{n\}    # 匹配连续 n 个前一个字符           如 echo 12223 | grep "12\{2\}"    匹配2次
\{n,\}   # 匹配至少 n 个前一个字符           如 echo 12223 | grep "12\{2,\}"   匹配至少2次
\{m,n\}  # 匹配其前面的字符至少m次，至多n次   如 echo 12223 | grep "12\{0,3\}"  匹配0至3次
3 字符集合
[:digit:]    # 所有数字           [0-9]     如 grep "[[:digit:]]" /etc/resolv.conf
[:lower:]    # 所有小写字母       [a-z]
[:upper:]    # 所有大写字母       [A-Z]
[:alpha:]    # 所有字母(含大小写)  [a-zA-Z]
[:alnum:]    # 所有字母和数字      [0-9a-zA-Z]
[:xdigit:]   # 16 进制的数值类型，包括 0-9、A-F、a-f

[:blank:]    # 空格与tab
[:space:]    # 空格或tab  任何会产生空白的字符，空格、tab、CR 等
[:punct:]    # 所有标点符号

[:cntrl:]    # 键盘上的控制按键，CR、LF、TAB、Del 等
[:graph:]    # 除了空格符(空格键与 tab 键)外其他的所有按键
[:print:]    # 任何可以被打印出来的字符

4 位置锚定
^   # 锚定行首 其后面的内容必须出现在行首  如 grep "^root" /etc/passwd 查找/etc/passwd中以root开头的行
$   # 锚定行尾 其前面的内容必须出现在行尾  如 grep "bash$" /etc/passwd 查找/etc/passwd中以bash结尾的行
^$  # 空白行                             如 grep "^$" /etc/php.ini |wc -l  统计/etc/php.ini中空白行
\<或\b   # 锚定词首，其后面的字符必须作为单词首部出现   如 grep "\<ro" file 等价于 grep "\bro" file
\>或\b   # 锚定词尾，其前面的字符必须作为单词尾部出现   如 grep "ot\>" file 等价于 grep "ot\b" file
\<条件\>或\b条件\b   # 查找某个独立的单词  如 grep "\<r..t\>" /etc/passwd  查找r开头，t结尾，中间两个字符的单词
5 grep的分组
\(\)
\(ab\)         # ab整体 作为匹配字符
\(ab\)*        # ab整体 作为匹配字符，且匹配任意次
\(ab\)\{1,\}   # ab整体 作为匹配字符，且匹配至少一次
分组还可以后向引用
\1             # 引用第1个左括号以及与之对应的右括号所包括的所有内容   如 grep "\(l..e\).*\1r" test2
\2             # 引用第2个左括号以及与之对应的右括号所包括的所有内容
\3             # 引用第3个左括号以及与之对应的右括号所包括的所有内容

a[a-z]\{0,2\}c  # [a-z]\{0,2\}要看成一组来理解，表示0-2个字母，这一组可以匹配 空 a aa ab这种


扩展的正则表达式  grep -E = egrep
1 字符匹配  扩展模式下的字符匹配与基本正则表达式的字符匹配相同
.      # 任意单个字符
[]     # 范围内人任意单个字符   如 [0-9] 任意单个数字
[^]    # 范围外的任意单个字符   如[^0-9] 数字外的任意单个字符
2 次数匹配  次数匹配就有些不一样了
*      # 匹配前面字符任意次    与基本正则表达式意义相同
?      # 匹配其前字符0次或1次  其前面相比不需要 \ 转义
+      # 匹配其前字符至少一次  等于基本正则表达式的  \{1, \}    ?+ = *
{m,n}  # 匹配其前字符至少m次 最多n次   等于基本正则表达式的\{m,n\}
3 位置锚定
与基本正则表达式完全意义
4分组  扩展正则表达式中，分组的功能更加强大，也可以说才是真正的分组
()     # 分组  后面可以使用\1 \2 \3...引用前面的分组
除了方便后面引用外，分组还非常方便的可以使用上述次数匹配方法进行匹配具有相同条件的数据
如 egrep '^(barlow).*\1' /etc/passwd   搜索/etc/passwd中以barlow开头，而后面还存在barlow的行
5 或
|      # 或 匹配的是其整个左边或右边   如 a|b 匹配a或b  B|barlow 匹配B或barlow (B|b)arlow 匹配Barlow或barlow


fgrep
不解析正则表达式 直接搜索文本 仅作为一般字符串处理 所有 meta 均失去功能
echo 'abc123{1,2}sd' | fgrep '{1,2}' # 匹配{1,2}










Shell中的重定向 < << > >> &< >& 都是重定向操作符
默认三个文件处于打开状态，标准输入(键盘输入),标准输出(输出到屏幕),标准错误(输出到屏幕)，分别对应文件描述符0,1,2
名称                 代码    操作符          Java中表示   Linux 下文件描述符(Debian 为例)
标准输入(stdin)       0      <   <<          System.in   /dev/stdin -> /proc/self/fd/0 -> /dev/pts/0
标准输出(stdout)      1      >,>> 或 1>,1>>  System.out  /dev/stdout -> /proc/self/fd/1 -> /dev/pts/0
标准错误输出(stderr)  2      2>    2>>       System.err  /dev/stderr -> /proc/self/fd/2 -> /dev/pts/0

输出重定向
> file     # 标准输出重定向，与 1> 相同 注意 1 与 > 之间不能有空格 1可省   2> 把标准错误重定向
n>file     # redirect file descriptor n to file
>> file    # 标准输出重定向(追加)   2>> file 把标准错误重定向到一个文件中(追加)
n>>file    # redirect file descriptor n to file. Create file if non-existent, else overwrite.
n>| file   # redirect file descriptor n to file. Create file even if noclobber is enabled.
2>&1       # 标准错误输出 重定向到 标准输出 或 2>& 1 其中 >& 为一个整体
  > file 2>&1 把标准输出和错误一起重定向到一个文件中  >> file 2>&1 把标准输出和错误一起重定向到一个文件中(追加)
&>file     # 把标准输出 和 标准错误输出 都重定向到文件file中 同 >& file 或 &> file
|&         # 管道 包含标准输出和标准错误 等价于 2>&1 |
/dev/null  # 表示一个空设备 如 > file 2> /dev/null 标准输出定向到文件，屏蔽掉错误输出

输入重定向
< file             # 以file文件作为标准输入
n<file             # redirect file descriptor n from file
< file > file2     # 以file文件作为标准输入，以file2作为标准输出
<< delimiter       # 从标准输入中读入，以  delimiter 为结束符。这就是 Bash 的 HereDoc 用法
n<<word            # redirect to file descriptor n until word is read
n<<-word           # redirect to file descriptor n until word is read; ignore leading tabs
cat < file > file  # file被洗掉 这只是个只是 priority 的问题，在 IO Redirection 中stdout 与 stderr的管道先准备好，
  才会从stdin读。> file 先将 file 清空，然后才读 < file ，但这时file已被清空了，因此就变成读不进任何资料了。

cat <<EOF > xx.cc    # 多行写入 xx.cc
xxx
XXX
EOF


绑定重定向
>&m        # 把标准输出重定向到文件描述符 m 中 等同于 1>&m  如 ls >&1
m>&n       # 把往文件描述符 m 的输出重定向到文件描述符 n 上  如2>&1
<&n        # redirect standard input from file descriptor n
n<&m       # redirect file descriptor n input from file descriptor m
<&-        # 关闭标准输入
2>&-       # 关闭标准错误输出，和 2>/dev/null 有类似功效
n<&-       # close file descriptor n for standard input
n>&-       # close file descriptor n for standard output
n<>file    # open file for reading and writing as file descriptor n
print &un args    # redirect arguments to file descriptor n. If n is greater than 2, it must first be opened with exec. If n is not specified, the default file descriptor argument is 1 (standard output).
read &un args     # read input line from file descriptor n. If n is greater than 2, it must first be opened with exec. If n is not specified, the default file descriptor argument is 0 (standard input).

其他
cat file1 | tee file2 file3   # tee 命令 可以同时重定向到多个文件
exec 1>file1  # 当前shell永久重定向 如 1 bash 打开一个shell 2 exec 1>file1 永久重定向 3 exit 推出当前shell
exec 4>file1  # 创建文件描述符  默认shell可以有9个打开的文件描述符 默认提供0 1 2 还可以用3-8 只是默认没有打开
exec 4>&-     # 关闭文件描述符

注
  1 file 表示文件    数字 m n 表示文件描述符
  2 The noclobber option prevents you from overwriting existing files with the > operator. 阻止覆盖已存在文件
    set -o noclobber   # 设置当前shell的noclobber属性 同set -C  关闭 set +o noclobber 同 set +C  详见 set --help
    设置了这个选项之后 xxx > existfile 会失败   但是 xxx >| existfile 可以

实验
exec 6>&1     # 将标准输出与fd 6绑定
ls  /proc/self/fd/  # 0  1  2  3  6  出现文件描述符6
exec 1>suc.txt   # 将接下来所有命令标准输出，绑定到suc.txt文件(输出到该文件)
ls -al        # 执行命令，发现什么都不返回了，因为标准输出已经输出到suc.txt文件了
exec 1>&6     # 恢复标准输出
exec 6>&-     # 关闭fd 6描述符
ls /proc/self/fd/   #0  1  2  3

2>&1 一般总要放到后面 如 xxx >log 2>&1  可以按照下面的方式理解
  过程 1. 本来1->屏幕  2. 执行>log后 1--log  3. 执行2>&1后 2->1 因为1->log 所以2->log
  若写为 2>&1 >log  过程 1. 本来1->屏幕  2. 执行2>&1后 2->1 因为1->屏幕 所以2->屏幕  3. 执行>log后 1->log 2不变 2->屏幕
>log 2>&1 的简写 &>log (更佳) 或 >&log 这3种写法等价 bash文档中有说明






环境变量
Linux 修改环境变量设置的三种方式
/etc/profile 文件     # 对所有的用户的都起作用的环境变量
~/bashrc 文件         # 仅用于当前用户有效的场景
var=value             # 仅当前命令行/控制台/shell可用   可用export导出用户环境变量

shell的两种变量
1 私有变量只在当前shell可见 通过赋值语句定义
  A1="1234"
  delcare A2="2345"   # delcare 可省
2.用户环境变量在所有shell可见 可通过export把私有变量导成用户环境变量
  A1="1234"           # 私有变量
  export A1           # 先定义再导出用户环境变量
  export A3="34"      # 直接定义用户环境变量



echo $PATH            # 显示单一环境变量
env                   # 显示当前用户环境变量
set                   # 显示当前shell所有变量，含私有变量和用户环境变量，按变量名称排序
export                # 显示当前导出成用户环境变量的shell变量，并显示变量的属性(是否只读)，按变量名称排序
export -n xxx         # 删除xxx的导出属性 并没有删除此变量 只是它的属性由用户环境变量变为私有变量
declare               # 同set
unset                 # 删除指定的私有变量或用户环境变量


              [env环境变量]  撤销导出属性
                  ↑  |   export -n aaa
                  |  |                     export aaa=123  定义本地变量的同时导出
  export aaa      |  ↓                     aaa=123         定义本地变量
   导出变量    [set本地变量]                unset aaa        删除变量 不管有没导出

进程的维度理解
set设置当前shell进程的本地变量，只在当前shell的进程内有效，不会被子进程继承和传递。
env仅为将要执行的子进程设置环境变量。
export将shell本地变量提升为当前shell进程的环境变量，从而被子进程自动继承，但export的变量无法改变父进程的环境变量。
source运行脚本的时候，不会启用一个新的shell进程，而是在当前shell进程环境中运行脚本。
exec运行脚本或命令的时候，不会启用一个新的shell进程，并且exec后续的脚本内容不会得到执行，即当前shell进程结束了。

进程和环境变量
进程是一个程序执行的上下文集合，这个集合包括程序代码、数据段、堆栈、环境变量、内核标识进程的数据结构等。
  一个进程可以生成一个子进程，子进程从父进程处继承环境变量。
  环境变量是一组特殊的字符型变量，由于具有继承性质，经常用于父子进程传递参数，这一点在shell编程中尤为突出。

fork和exec
在unix系统中进程通过依次调用fork()和exec()系统调用来实现创建一个子进程。
fork就是克隆，在内存中将当前进程的内存镜像复制一份，只修改新进程的进程号(PID)。
  fork复制整个进程，包括进程运行到哪句代码，父子进程都会继续执行fork后面的代码，从fork开始父子进程才分道扬镳。
exec是一组函数的统称，并且exec的准确定义是，用磁盘上的一个新的程序替换当前的进程的正文段、数据段、堆栈段。
  所以exec并不产生新的进程，而是替换。进程将从新代码的main开始执行，运行一个完全不同的程序，但保留了原来环境变量。
exec函数分两类，一可以设置并传递新环境变量的，二不能传递新环境变量的，只能继承原环境变量的。
  在运行新的程序时，可选择改变新程序的环境变量的，而不只是继承。
  int execve(const char * filename,char * const argv[ ],char * const envp[ ]);  # 通过envp参数设置环境变量
对父进程，可以通过waitpid()函数等待子进程退出，并获得退出状态。
进程可通过setenv或putenv更改自己的环境变量，但环境变量的继承只能单向，即从父进程继承给fork出来的子进程。
  子进程即使修改了自己的环境变量也无法动摇到父进程的环境变量。

shell
shell没有特殊，也是一个进程，在命令行中敲入一个命令，Enter后，shell进程通过fork和exec创建一个子进程
(小部分命令不需要启动子进程，称为build-in命令)，并且等待(waitpid)这个子进程完成退出。进程的内存镜像显然就包含环境变量。
如 shell命令行中执行ls -al，shell实际执行如下伪代码
  pid = fork();
  if(pid == 0) {
    exec("ls -al"); //子进程中，调用exec
  } else if(pid > 0) {
    waitpid(pid);   //父进程中，waitpid等待子进程退出
  }
默认情况下，在命令行中执行一个shell脚本，shell进程会创建一个sub-shell子进程来执行这个shell脚本，且等待这个子进程执行结束。
set,source,export都是shell的build-in命令，命令本身不会创建新进程。
set跟进程创建无关，也跟环境变量无关，只是当前shell进程内部维护的本地变量，用于变量的引用和展开，不能遗传和继承。
export调用putenv将本地变量提升为当前shell的环境变量。环境变量是单向继承的，sub-shell中export的变量在父shell中是看不到的。
source ./test.sh   # 让一个脚本中export变量改变父进程的环境变量
  source执行脚本，fork和exec不会调用，当前shell直接解释执行test.sh。若test.sh中有export，就会改变当前shell的环境变量。
env XXX=crash ./test.sh  # 临时启用环境变量XXX 而不影响后面的命令 因为export几乎会影响到其后的所有命令
  env不是shell的build-in命令，所以shell执行env的时候还是需要创建子进程的
  env从本质上说，相当于shell先fork，在子进程中运行env，调用execve运行test.sh时，
  多传了一个XXX=crash的环境变量(上文提到过execve是可以改变默认的继承行为的)，
  这样test.sh可以看到环境变量XXX，但由于没有调用putenv改变父shell的环境变量，所以后续启动的进程并不继承XXX。
不调fork，直接调exec执行。当前shell执行exec后，代码被替换成exec要执行的程序，后续脚本不会执行，因为shell本身都被替换掉了。
1.sh    例子
#!/bin/bash
A=B
echo "PID for 1.sh before exec/source/fork:$$"
export A
echo "1.sh: \$A is $A"
case $1 in
    exec)
        echo "using exec…"
        exec ./2.sh;;
    source)
        echo "using source…"
        . ./2.sh;;
    *)
        echo "using fork by default…"
        ./2.sh;;
esac
echo "PID for 1.sh after exec/source/fork:$$"
echo "1.sh: \$A is $A"

2.sh
#!/bin/bash
echo "PID for 2.sh: $$"
echo "2.sh get \$A=$A from 1.sh"
A=C
export A
echo "2.sh: \$A is $A"

然后，分别跑如下参数来观察结果
$ ./1.sh fork     # PID 1 before 315   PID for 2 316   2 get $A=B   2 $A is C   PID 1 after 315   1 $A is B
$ ./1.sh source   # PID 1 before 315   PID for 2 315   2 get $A=B   2 $A is C   PID 1 after 315   1 $A is C
$ ./1.sh exec     # PID 1 before 315   PID for 2 315   2 get $A=B   2 $A is C


 [export]      [no source]                [source]           [exec]            [env]
____________  ____________            _______________    _______________    _______________
|   envs   |  |   envs   |__  fork    |   envs      |    |   envs      |    |   envs       |__  fork
|          |  |          |  ↘________ |             |    |             |    |              |  ↘_______
|   A=x    |  |          |   | envs | |             |    |             |    |              |   | envs |
|__________|  |__________|   |______| |_____________|    |_____________|    |______________|   | A=x  |
|    ↑     |  |./x.sh    |-→ |      | |source ./x.sh|    |exec ./x.sh  |    |env A=x ./x.sh|-→ |______|
|export A=x|  |          |←- |______| |  _________  |    |_____________|    |              |←- |______|
|          |  |          |            | | ./x.sh  | |    |   ./x.sh    |    |              |
|__________|  |__________|            | |_________| |    |             |    |______________|
                                      |_____________|    |_____________|


环境变量配置文件(Ubuntu16.04)
/etc/profile        # 设置系统级的环境变量和启动程序，在这个文件下配置会对所有用户生效。当用户登录(login)时，
  文件会被执行，并从/etc/profile.d目录的配置文件中查找shell设置。如果对/etc/profile修改的话必须重启才会生效
/etc/bash.bashrc    # 每运行一个bash shell就执行此文件.当bash shell被打开时,该文件被读取。
  修改这个文件对所有使用bash的用户都生效，修改之后不用重启，重新打开一个bash即可生效。
~/.profile          # 定义每个用户自己的shell信息,登录时,该文件仅仅执行一次!它设置一些环境变量,执行用户的.bashrc文件.
~/.bashrc           # 专用于用户自己的bash信息,当登录时以及每次打开新的shell时,该该文件被读取.
~/.bash_logout      # 当每次退出系统(退出bash shell)时,执行该文件，通常存放清理工作的命令。

全局配置文件
  /etc/profile
  /etc/profile.d/*.sh
  /etc/bashrc
个人配置文件
  ~/.bash_profile
  ~/.bashrc
profile 类文件作用
  1.设定环境变量
  2.运行命令或脚本(登录时运行的脚本)。
bashrc 类文件配置作用
  1.设定本地变量。
  2.定义命令别名

登陆shell ----> /etc/profile ----> ~/.bash_profile ---->  开始才做bash
                |---> /etc/inputc              |(~/.bash_login ~/.profile)
                |---> /etc/profile.d/*.sh      |---> ~/.bashrc           <---- 非登陆shell
                       |--> /etc/sysconfig/i18n           |-->/etc/bashrc

~/.bash_logout                                                                     # shell登出时读取
/etc/profile –> /etc/profile.d/*.sh –> ~/.bash_profile–> ~/.bashrc –> /etc/bashrc  # 登陆shell执行顺序
~/.bashrc –> /etc/bashrc –> /etc/prodile.d/*.sh                                    # 非登陆shell执行顺序
source ~/.bash_profile 等价 . ~/.bash_profile   # 修改之后立即生效

su [-lm] [-c 命令] [username]
  -  # "su -" 使用login-shell的方式来登陆系统；省略用户名，切换为root身份
  -l # 与 - 类似，但后面需要加用户名！也是 login-shell 的方式
  -m # 与 -p 一样，使用目前的环境配置，而不读取新使用者的配置文件
  -c # 仅执行一次命令，-c 后面可以加上命令  如 su -l lixiang -c "pwd"
  注 "su" 切换到root用户，以non-login shell的方式登陆；而"su -" 以login-shell切换root用户。

登陆shell(login shell)             取得 bash 时需要完整的登陆流程
  通过ssh连接，或由tty1 ~ tty6 登陆，需要输入用户的账号与密码，此时取得的 bash 就称为login shell
  su - username 或 su -l username   # 指定用户登录
  bash -l xx.sh      # 登录模式  bash默认是非登录的，--login选项(简写为-l)为登录式

非登陆shell(non-login shell)       取得 bash 接口的方法不需要重复登陆的举动
  登陆 Linux 后， 再启动终端Terminal，该终端接口并没有输入账号与密码,那个 bash 的环境就 non-login shell
  在原本的bash环境下再次使用bash命令，建立一个bash子进程，同样也没有输入账号密码，那第二个bash是 non-login shell
  su username
  图形终端下打开的命令窗口
  自动执行的 shell 脚本
  bash xx.sh         # 非登录模式

交互式shell(interactive shell)
  终端上shell等待输入，立即执行提交的命令。shell与用户进行交互。登录、执行一些命令、退出。当退出后，shell也终止了。

非交互式shell(non-interactive shell)
  以shell script(非交互)方式执行。shell不与你交互，而是读取存放在文件中的命令并执行。当读到文件结尾EOF，shell就终止了。

tty       # 显示 /dev/pts/4  当前从ssh登陆到服务器
ps        # 显示当前tty        ps -ef|grep pts|grep bash 显示所有的

echo $0            # 显示 -bash 为登陆shell   显示 /bin/bash 为非登陆shell
shopt login_shell  # 显示 login_shell    on为登录shell  off为非登录式    如在脚本中则显示off

echo $-   # himBHs  i表示交互式   echo 'echo $-' | bash  或 bash ./test.sh (.sh中echo $-) 显示 hBs  非交互
echo $PS1 # 非空为交互式 非交互式会清空该变量 如 bash ./test.sh (.sh中echo PS1)为非交互式

通过 Linux 控制台(不是桌面环境自带的终端)或者 ssh 登录 Shell 时(这才是正常登录方式)，为交互式的登录 Shell。
在 Linux 桌面环境下打开终端时，为交互式的非登录 Shell。

()中的命令或命令替换进入子Shell时，子Shell会继承父Shell的交互和登录属性。
  bash
  (echo $PS1;shopt login_shell)   # 非登录交互式模式
  bash -l
  (echo $PS1;shopt login_shell)   # 登录交互式模式

ssh 执行远程命令，但不登录时，为非交互非登录式。
  ssh localhost 'echo $PS1;shopt login_shell'       # 非交互非登录模式
  ssh name@ip 'echo $PS1;shopt login_shell'         # 即便是让输入密码 也是非交互非登录模式






shell 脚本(script) 示例 0.sh
https://haicoder.net/shell/shell-function-return.html

执行一个 Shell 脚本，有四种方式，即使用点.、使用绝对路径或相对路径执行、使用 sh 执行和使用 source 执行。

Shell 中，命令分为内建命令和外部命令
内置命令
Bash 自身提供的命令，而不是文件系统中的某个可执行文件。执行内建命令相当于调用当前 Shell 进程的一个函数。
外部命令
执行外部命令时会触发磁盘 I/O，需要 fork 出一个单独的进程来执行，执行完成后再退出。通常内建命令会比外部命令执行得更快。

help xxx       # help显示内建命令的简要帮助信息
xxx --help     # 外部命令 使用--help参数
man xxx        # 所有命令的详细信息
info xxx       # 所有命令的更见详细描述
type xxx       # 命令类型 -a 所有指令和位置 -t file外部命令 alias别名 builtin内置命令 -p 外部指令显示完整文件名

alias                # 所有别名   一般定义在 ~/.bashrc(source ~/.bashrc 生效)
alias new_cmd="cmd"  # 设置别名  如 alias lsl='ls -l'
unalias new_cmd      # 删除别名  如 unalias lsl
指令前加反斜杠 \      # 临时取消使用别名 即 忽略掉 alias 的指定选项  如 \ls 直接调用ls的原始命令




read [-options] [variables]
从标准输入中读取数据并赋值给变量。默认从键盘读取用户输入的数据；若进行了重定向，可从文件中读取数据。
options    # 命令使用的选项
variables  # 用来存储数据的变量，可以有一个，也可以有多个
options 和 variables 都是可选的，如果没有提供变量名，那么读取的数据将存放到环境变量 REPLY 中。
-a         # array 把读取的数据赋值给数组 array，从下标 0 开始。
-d         # delimiter 用字符串 delimiter 指定读取结束的位置，而不是一个换行符(读取到的数据不包括 delimiter)。
-e         # 在获取用户输入的时候，对功能键进行编码转换，不会直接显式功能键对应的字符。
-n         # num 读取 num 个字符，而不是整行字符。但是分隔符仍然有效
-N         # 在准确读取了 num 个字符之后返回，除非遇到文件结束符或者读超时，任何的分隔符都被忽略
-p         # prompt 显示提示信息，提示内容为 prompt。
-r         # 原样读取(Raw mode)，不把反斜杠字符解释为转义字符。
-s         # 静默模式(Silent mode)，不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这是很有必要的。
-t         # seconds 设置超时时间，单位为秒。若用户没有在指定时间内输入完成，read 将会返回一个非 0 的退出状态，表示读取失败。
-u         # fd 使用文件描述符 fd 作为输入源，而不是标准输入，类似于重定向。
read -p "please input info > " name url age      # 读取3个变量
read -n 1 -p "Enter a char > " char              # 读取单个字符
read -t 20 -sp "Enter password in 20 seconds > " pass1 && printf "\n"  # 输入密码 不回显 超过20s不输入程序自动结束

读取文件的几种方式
1 按字符数量读取 每次读取一个或多个字符 直到把整个文件读完
read -n 1 data <a.txt       # 只读一个字符
read -n 100 data < a.txt    # 读100个字符，但如果不足100字符时遇到换行符则停止读取
read -N 100 data < a.txt    # 强制读取100字符，遇到换行符也不停止

while read -N 3 data;do     # 正确 按字符数量读取，直到读完文件，将文件放在 while 结构的后面，而不能放在 while 循环的条件位置
  echo "$data"
done <a.txt

while read -N 3 data < a.txt;do  # 错误
  echo "$data"
done

2 按分隔符读取
read -d "m" data <a.txt     # 一直读取，直到遇到字符m才停止，并将读取的数据保存到data变量中

while read -d "m" data ;do  # 如果要按分隔符读取并读完整个文件，则使用 while 循环
  echo "$data"
done <a.txt

3 按行读取
read line <a.txt            # read 默认情况下就是按行读取的，一次读取一行

while read line;do          # 如果要求按行读取完整个文件，则使用 while 循环
  echo "$line"
done <a.txt

4 一次性读整个文件
  1 按照字符数量读取，且指定的字符数要大于文件的总大小
  2 按分隔符读取，且指定的分隔符是文件中不存在的字符，这样的话会一直读取，因为找不到分隔符而读完整个文件
read -N 1000000 data <a.txt  # 指定超出文件大小的字符数量
echo "$data"

read -d "_" data <a.txt      # 指定文件中不存在的字符作为分隔符
echo "$data"





内置命令列表  help展示
:          # 扩展参数列表，执行重定向操作
.          # 读取并执行指定文件中的命令(在当前 shell 环境中)
alias      # 为指定命令定义一个别名
bg         # 将作业以后台模式运行
bind       # 将键盘序列绑定到一个 readline 函数或宏
break      # 退出 for、while、select 或 until 循环
builtin    # 执行指定的 shell 内建命令
caller     # 返回活动子函数调用的上下文
cd         # 将当前目录切换为指定的目录
command    # 执行指定的命令，无需进行通常的 shell 查找
compgen    # 为指定单词生成可能的补全匹配
complete   # 显示指定的单词是如何补全的
compopt    # 修改指定单词的补全选项
continue   # 继续执行 for、while、select 或 until 循环的下一次迭代
declare    # 声明一个变量或变量类型。
dirs       # 显示当前存储目录的列表
disown     # 从进程作业表中刪除指定的作业
echo       # 将指定字符串输出到 STDOUT
enable     # 启用或禁用指定的内建shell命令
eval       # 将指定的参数拼接成一个命令，然后执行该命令
exec       # 用指定命令替换 shell 进程
exit       # 强制 shell 以指定的退出状态码退出
export     # 设置子 shell 进程可用的变量
fc         # 从历史记录中选择命令列表
fg         # 将作业以前台模式运行
getopts    # 分析指定的位置参数
hash       # 查找并记住指定命令的全路径名
help       # 显示帮助文件
history    # 显示命令历史记录
jobs       # 出活动作业
kill       # 向指定的进程 ID(PID) 发送一个系统信号
let        # 计算一个数学表达式中的每个参数
local      # 在函数中创建一个作用域受限的变量
logout     # 退出登录 shell
mapfile    # 从 STDIN 读取数据行，并将其加入索引数组
popd       # 从目录栈中删除记录
printf     # 使用格式化字符串显示文本
pushd      # 向目录栈添加一个目录
pwd        # 显示当前工作目录的路径名
read       # 从 STDIN 读取一行数据并将其赋给一个变量
readarray  # 从 STDIN 读取数据行并将其放入索引数组
readonly   # 从 STDIN 读取一行数据并将其赋给一个不可修改的变量
return     # 强制函数以某个值退出，这个值可以被调用脚本提取
set        # 设置并显示环境变量的值和 shell 属性
shift      # 将位置参数依次向下降一个位置
shopt      # 打开/关闭控制 shell 可选行为的变量值
source     # 读取并执行指定文件中的命令(在当前 shell 环境中)
suspend    # 暂停 Shell 的执行，直到收到一个 SIGCONT 信号
test       # 基于指定条件返回退出状态码 0 或 1
times      # 显示累计的用户和系统时间
trap       # 如果收到了指定的系统信号，执行指定的命令
type       # 显示指定的单词如果作为命令将会如何被解释
typeset    # 声明一个变量或变量类型。
ulimit     # 为系统用户设置指定的资源的上限
umask      # 为新建的文件和目录设置默认权限
unalias    # 刪除指定的别名
unset      # 刪除指定的环境变量或 shell 属性
wait       # 等待指定的进程完成，并返回退出状态码



流程结构
if         # 条件判断
if  condition
then
    statement(s)
fi

if  condition; then     # then 和 condition 写在一行 需要加一个分号
    statement(s)
fi



if else    # 条件判断2
if condition
then
   statement
else
   statementn
fi



elif       # 条件判断3
if  condition1
then
   statement1
elif condition2
then
    statement2
elif condition3
then
    statement3
fi



if elif else  # 条件判断4
if  condition1
then
   statement1
elif condition2
then
    statement2
elif condition3
then
    statement3
else
   statementn
fi



case in
支持两种分支结构，分别是 if else 语句和 case in 语句。当分支较多，且判断条件比较简单时，case in 语句较方便。
case expression in
    pattern1)
        statement1
        ;;
    pattern2)
        statement2
        ;;
    pattern3)
        statement3
        ;;
    ……
    *)
        statementn
esac

case、in 和 esac 都是 Shell 关键字，expression 表示表达式，pattern 表示匹配模式。
expression 可以是一个变量、一个数字、一个字符串，一个数学计算表达式，命令的执行结果，只要能够得到 expression 的值就可以。
pattern 可以是一个数字、一个字符串，甚至是一个简单的正则表达式。
case 会将 expression 的值与 pattern1、pattern2、pattern3 逐个进行匹配
expression 和某个模式匹配成功，就会执行这模式后面对应的所有语句，直到遇见双分号;;才停止；跳出 case，执行 esac 后面的语句。
expression 没有匹配到任何一个模式，就执行 *) 后面的语句，直到遇见双分号 ;; 或 esac 结束。 *) 相当于 if 语句中的 else 。
这里的 ;; 和 *) 就相当于其它编程语言中的 break 和 default。



while      # 循环1  当条件成立时，一直执行循环里的逻辑
while condition
do
  statements
done



until循环  # 循环2 当条件不成立时才进行循环，一旦判断条件成立，就终止循环。跟 while 相反
until condition
do
  statements
done


for        # 循环3
for ((express1; express2; express3))
do
  statements
done



for in     # 循环4
for variable in value_list
do
  statements
done
从 value_list 中取出一个值赋给变量 variable，然后进入循环体执行 statements。直到取完 value_list 中的所有值。



select in  # 循环5
select variable in value_list
do
    statements
done
增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能。
注意，select 是无限循环(死循环)，输入空值，或者输入的值无效，都不会结束循环，只有遇到 break 语句，
  或者按下 Ctrl+D 组合键才能结束循环。

select name in "Linux" "Windows" "Mac OS" "UNIX" "Android"
do
    echo $name
done


continue   # 循环时，在某种条件满足的情况下，需要跳过本次循环，继续执行下一次循环
for ((i = startIndex; i < endIndex; i++))
do
    if ((condition))
    then
        continue;
    fi
    # do something
done



break      # 循环时，在某种条件满足的情况下，需要终止循环的继续执行
for ((i = startIndex; i < endIndex; i++))
do
    if ((condition))
    then
        break;
    fi
    # do something
done





变量
shell 中每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。
variable=value           # 定义变量 赋值号 = 的周围不能有空格
variable='value'
variable="value"         # 如果 value 包含了空白符，那么就必须使用引号包围起来。
echo $variable           # 使用变量 只要在变量名前面加美元符号即可
echo ${variable}         # 变量名外面的大括号是可选的，加大括号是为了帮助解释器识别变量的边界

variable=`ls /etc`       # 命令结果赋值给变量 同下
variable=$(ls /etc)

unset variable           # 删除变量 unset 命令不能删除只读变量

local name="test"        # 局部变量(local修饰的变量在函数体外无法访问，且local只能在函数体内使用)
url=xxx
readonly url             # 将变量声明为只读的 不能删除与修改

删除只读变量              # 测试失败 可能是权限问题
cat << EOF| gdb
attach $$
call unbind_variable("只读变量")
detach
EOF

变量的值为变量名
aa=25
bb=aa
echo \$$bb               # $aa  一次扫描时  $bb被其值aa替换，变成 echo $aa
eval echo \$$bb          # 25   二次扫描时  $aa被替成25，    变成 echo 25



变量有三种状态 未定义(unset) 空值(null) 非空值(not null)     分别表示为   - 0 x
str=${var-DEF}    # var 为 -   则str=DEF  var不变       var 为 0 x  则str=$var  var不变
str=${var:-DEF}   # var 为 - 0 则str=DEF  var不变       var 为   x  则str=$var  var不变
str=${var+DEF}    # var 为 -   则str=空  var不变        var 为 0 x  则str=DEF   var不变
str=${var:+DEF}   # var 为 - 0 则str=空  var不变        var 为   x  则str=DEF   var不变
str=${var=DEF}    # var 为 -   则str=DEF  var=DEF       var 为 0 x  则str=$var  var不变
str=${var:=DEF}   # var 为 - 0 则str=DEF  var=DEF       var 为   x  则str=$var  var不变
str=${var?DEF}    # var 为 -   则stderr打印DEF 程序退出  var 为 0 x  则str=$var  var不变
str=${var:?DEF}   # var 为 - 0 则stderr打印DEF 程序退出  var 为   x  则str=$var  var不变
str=${!DEF*}      # 匹配所有以DEF开头的变量 如 声明了变量var var2 var3 则${!va*} 返回 "var var2 var3"
str=${!DEF@}      # 同 ${!DEF*}

-  # 不存在则给默认值， 存在则使用原始值
+  # 不存在不给值，     存在则给默认值
=  # 不存在则给变量赋值，存在则使用原始值
?  # 不存在则报错，     存在则使用原始值

str=12343456
${#str}                # 字符串$str的长度  ${#str} -> 8
${str:pos}             # 从$pos开始提取右侧子串 下标从左向右 从 0 开始  ${str:3} -> 43456
${str:0-pos}           # 从$pos开始提取右侧子串 下标从右向左 从 1 开始  ${str:0-3} -> 456
${str:pos:length}      # 从$pos开始提取右侧长度为$length的子串 下标从左向右 从 0 开始  ${str:3:2} -> 43
${str:0-pos:length}    # 从$pos开始提取右侧长度为$length的子串 下标从右向左 从 1 开始  ${str:0-3:2} -> 45
${str#sub}             # 从$str开头开始删除最短匹配$sub的子串 取右边部分  ${str#*34} -> 3456
${str##sub}            # 从$str开头开始删除最长匹配$sub的子串 取右边部分  ${str##*34} -> 56
${str%sub}             # 从$str结尾开始删除最短匹配$sub的子串 取左边部分  ${str%34*} -> 1234
${str%%sub}            # 从$str结尾开始删除最长匹配$sub的子串 取左边部分  ${str%%34*} -> 12
${str/sub/replace}     # 使用$replace, 来代替第一个匹配的$sub     ${str/34/ab} -> 12ab3456
${str/sub}             # 若没有指定新值，则第一个匹配的字串会被删除 ${str/34} -> 123456
${str/*} 或 ${str/@}   # 删除所有   ${str/*} -> 空   ${str/@} -> 12343456
${str//sub/replace}    # 使用$replace, 代替所有匹配的$sub         ${str//34/ab} -> 12abab56
${str//sub}            # 若没有指定新值，则所有匹配的字串会被删除   ${str//34} -> 1256
${str//*} 或 ${str//@} # 删除所有   ${str//*} -> 空   ${str//@} -> 12343456
${str/#sub/replace}    # 若$str的前缀匹配$sub 就用$replace来代替匹配到的$sub  ${str/#12/ab} -> ab343456
${str/%sub/replace}    # 若$str的后缀匹配$sub 就用$replace来代替匹配到的$sub  ${str/%56/ab} -> 123434ab
str=$str1$str2         # 拼接字符串
name=1,2!3.123 ${name/[[:punct:]]} 12!3.123  # 使用范围符号删除
name=1,2!3.123 ${name//[[:punct:]]} 123123   # 使用范围符号删除
echo `expr index "$string" io`  # 输出 4 查找字符 i 或 o 的位置 string="runoob is" 注意 ` 是反引号




数组
数组中可以存放多个值。bash 只支持一维数组 不支持多维数组 初始化时不需要定义数组大小 数组元素的下标由 0 开始。
array_name=(value1 value2 ... valuen)      # 语法格式 数组用括号来表示 元素用"空格"符号分割开
array_name[0]=value0;array_name[1]=value1  # 使用数字下标来定义数组

关联数组
declare -A array_name  # 语法格式 可以使用任意的字符串或整数作为下标来访问数组元素
  如 declare -A site=(["A"]="A.a" ["B"]="B.b" ["C"]="C.c") # -A 选项就是用于声明一个关联数组 主键唯一
  或 declare -A site;  site["A"]="A.a";site["B"]="B.b";

${array_name[index]}                     # 读取数组单个元素
${array_name[@]} 或 ${array_name[*]}     # 获取数组所有元素
${!array_name[@]} 或 ${!array_name[*]}   # 获取数组的所有键
${#array_name[@]} 或 ${#array_name[*]}   # 获取数组的长度  使用 @ 或 * 将数组转成列表 再次使用 # 获取数组长度
array_new=(${array1[@]}  ${array2[@]})   # 数组拼接  使用 @ 将数组转成列表，再次将两个数组写在一起，实现了数组的拼接
unset array_name[index]                  # 删除数组指定下标的元素
unset array_name                         # 删除整个数组



declare
declare 和 typeset 都是 Shell 内建命令，用法相同，都用来设置变量的属性。不过 typeset 已经被弃用了，建议使用 declare。
declare [+/-] [aAfFgilprtux] [变量名=变量值]
选项      含义
-f [name]           # 列出之前由用户在脚本中定义的函数名称和函数体。
-F [name]           # 仅列出自定义函数名称。
-g name             # 在 Shell 函数内部创建全局变量。
-p [name]           # 显示指定变量的属性和值。
-a name             # 声明变量为普通数组。
-A name             # 声明变量为关联数组(支持索引下标为字符串)。
-i name             # 将变量定义为整数型。
-r name[=value]     # 将变量定义为只读(不可修改和删除)，等价于 readonly name。
-x name[=value]     # 将变量设置为环境变量，等价于 export name[=value]。
其中，- 表示设置属性，+表示取消属性，aAfFgilprtux 都是具体的选项。
declare -i m n ret  # 将多个变量声明为整数
declare -i sum=100+300+50  # echo ${sum} -> 450 若没有-i 则  echo ${sum} -> 100+300+50
declare -r n=10     # 将变量声明为只读变量



单引号 '
单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
单引号字串中不能出现单独一个的单引号(对单引号使用转义符后也不行)，但可成对出现，作为字符串拼接使用。

双引号 "
双引号里可以有变量,除$ \ ' " 这几个字符仍是特殊字符并保留其特殊功能外，其余字符仍作为普通字符对待。
双引号里可以出现双引号，只要它被转义了就行  如  \"  解析为 "
其他的转义字符跟单引号一样 原样保存在变量中 单引号 \' 也会保存为 \'

反引号 `
反引号括起来的字符串被shell解释为命令行，执行时，shell首先执行该命令行，并以它的标准输出结果取代整个反引号部分。
反引号还可以嵌套使用。但需注意，嵌套使用时内层的反引号必须用反斜杠(\)将其转义。如下
$ abc=`echo The number of users is \`who| wc -l\``
$ echo $abc
The number of users is 2
在反引号之间的命令行中也可以使用shell的特殊字符。Shell为得到``中命令的结果，它实际上要去执行``中指定的命令。
执行时，命令中的特殊字符，如$，”，?等又将具有特殊含义，并且``所包含的可以是任何一个合法的Shell命令，如
$ ls
note readme.txt Notice Unix.dir
$ TestString="`echo $HOME ` ` ls [nN]*`"
$ echo $TestString
/home/yxz note Notice
题外话:反引号是一个老的用法，$()才是新的用法，推荐使用$()，所以上面的的用法可以改成
$ TestString="$(echo $HOME) $(ls [nN]*)"
$ echo $TestString
/home/yxz note Notice



shell 中各种括号的作用()、(())、[]、[[]]、{}
http://blog.csdn.net/taiyang1987912/article/details/39551385
1 单小括号 ()
  1.1 命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。
    括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。
    如 pwd;(cd code/;pwd);(cd code/; pwd);pwd
  1.2 命令替换。等与`cmd`，命令行$(cmd)进行扩展，将cmd的标准输出替换原命令。tcsh不支持。如 ls $(find ./ -name 12 )
  1.3 用于初始化数组。如 array=(a b c d)

2 双小括号 (())
  2.1 整数扩展。((exp))扩展并计算一个整数算术表达式的值，不支持浮点型。
    exp结果为0，false；非0，true。对逻辑判断，exp为真则为1,假为0。如 echo $((1+2))  echo $((1<2));echo $?
  2.2 只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。
    不同进位(2 8 16)运算时，输出结果全都自动转化成了十进制。如 echo $((16#5f)) 结果为95 (16进位转十进制)
  2.3 单纯用 (()) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6
  2.4 常用于算术运算比较，双括号中的变量可不使用$前缀，支持多个表达式用逗号分开，表达式符合C语言运算规则。
    如 for((i=0;i<5;i++)) 等价于 for i in `seq 0 4`或for i in {0..4}。if (($i<5)) 等价于 if [ $i -lt 5 ]。

3 单中括号 []
  3.1 是bash 的内部命令，和test等价。if/test结构中的[是调用test的命令标识，]是关闭条件判断的。
    它参数的比较/判断结果返回一个退出状态码。if/test结构中并不是必须有中括号，但新版的Bash中要求必须这样。
    两边和每个组件都需要有空格，如 [ $a == $b ] 正确    [$a==$b] 错误
  3.2 Test和[]中比较运算符只有==和!=，两者都只用于字符串比较，整数比较只能用-eq，-gt这种形式。
    字符串/整数比较都不支持> <；字符串比较可用转义形式，如 [ ab \< bc ]，结果为真，也就是返回状态为0。
    []中的逻辑与和逻辑或使用-a 和-o 表示。
    if [ 1 -gt 2 ]; then echo 11; else echo 22; fi   # 使用 [...] 判断语句中大于使用 -gt，小于使用 -lt
    if ((1 < 2)); then echo 11; else echo 22; fi     # 使用 ((...)) 作为判断语句，大于和小于可以直接使用 > 和 <。
  3.3 字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。
  3.4 在一个array结构的上下文中，中括号用来引用数组中每个元素的编号。
  3.5 通配符扩展 匹配[]中任一单个字符   如 ls /[eh][to][cm]* -> ls /etc /home     mkdir命令不能扩展

4 双中括号[[]]
  4.1 是 bash 内置关键字，不是命令。[[]]比[]更通用。[[]]中所有字符都不会发生文件名扩展或单词分割，只会参数扩展和命令替换。
    [[]]在使用时没有给函数传递参数的过程，故 test 命令的某些注意事项在 [[]] 中就不存在了，具体有
      不需要把变量名用双引号""包围起来，即使变量是空值，也不会出错。
      不需要、也不能对 >、< 进行转义，转义后会出错。
    检测某个条件是否成立。test 能做的，[[]] 也能做，且做的更好；test 做不到的，[[]] 还能做到。[[]] 是 test 的升级版。
    [[ expr ]] # 判断 expr 成立时，退出状态为 0，否则为非 0。注意 [[]] 两端的空格是必须的，否则会导致语法错误。
  4.2 支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，
    而不仅仅是一个字符串，如 [[ hello == hell? ]]，结果为真。[[]] 中匹配字符串或通配符，不需要引号。
  4.3 使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。
    如 &&、||、<和> 操作符能够正常存在于[[]]条件判断结构中，但是如果出现在[]结构中的话，会报错。
    如 if [[ $a != 1 && $a != 2 ]] 等价于 if [ $a -ne 1] && [ $a != 2 ] 或 if [ $a -ne 1 -a $a != 2 ]。
    逻辑运算符 可放入[[]]  而[] 不行
    if [[ 1 -lt 2 && 2 -lt 3 ]]; then echo 11; else echo 22; fi
    if [ 1 -lt 2 ] && [ 2 -lt 3 ]; then echo 11; else echo 22; fi  # 同上
    if (( 1 < 2 && 2 < 3 )); then echo 11; else echo 22; fi
  4.4 bash把[[]]中的表达式看作一个单独的元素，并返回一个退出状态码。

例子
if ($i<5)      此处有问题,改为if (($i<5))
if [ $i -lt 5 ]
if [ $a -ne 1 -a $a != 2 ]
if [ $a -ne 1] && [ $a != 2 ]
if [[ $a != 1 && $a != 2 ]]

for i in $(seq 0 4);do echo $i;done
for i in `seq 0 4`;do echo $i;done
for ((i=0;i<5;i++));do echo $i;done
for i in {0..4};do echo $i;done

5 大括号、花括号 {}
  5.1常规用法
    5.1.1 大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。
      对大括号中的以逗号分割的文件列表进行拓展。       如 touch {a,b}.txt  -> a.txt b.txt。
      对大括号中以点点(..)分割的顺序文件列表起拓展作用 如 touch {a..d}.txt -> a.txt b.txt c.txt d.txt
      ls {ex1,ex2}.sh       -> ex1.sh  ex2.sh
      ls {ex{1..3},ex4}.sh  -> ex1.sh  ex2.sh  ex3.sh  ex4.sh
      ls {ex[1-3],ex4}.sh   -> ex1.sh  ex2.sh  ex3.sh  ex4.sh
    5.1.2 代码块，又被称为内部组，这个结构事实上创建了一个匿名函数。
      与()中的命令不同，{}内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。
      {}内命令用分号隔开，第一个命令和{之间必须有一个空格，最后一个命令必须有分号。如 { pwd;}

  5.2 几种特殊的替换结构
    ${var:-string}
    ${var:+string}
    ${var:=string}
    ${var:?string}
    string不一定是常值，可用另外一个变量的值或是一种命令的输出。详见下面 变量栏

  5.3 四种模式匹配替换结构
    # 是去掉左边(在键盘上#在$之左边)
    % 是去掉右边(在键盘上%在$之右边)
    #和%中的单一符号是最小匹配，两个相同符号是最大匹配。详见下面 变量栏

  5.4 字符串提取和替换
    ${var:num}
    ${var:num1:num2}
    ${var/pattern/pattern}
    ${var//pattern/pattern}
    详见下面 变量栏

6 符号$后的括号
  6.1 ${a} 变量a的值, 在不引起歧义的情况下可以省略大括号。
  6.2 $(cmd) 命令替换，和`cmd`效果相同，结果为cmd的输出，不过某些Shell版本不支持$()形式的命令替换, 如 tcsh
  6.3 $((exp)) 和`exp`效果相同, 计算数学表达式exp,exp只要符合C语言的运算规则即可,三目运算符和逻辑表达式都可以计算。

7 使用
  7.1 多条命令执行
    1 单小括号 (cmd1;cmd2;cmd3) 新开一个子shell顺序执行命令cmd1,cmd2,cmd3,命令用分号隔开, 最后一条命令后可省分号。
    2 单大括号 { cmd1;cmd2;cmd3;} 在当前shell顺序执行命令cmd1,cmd2,cmd3,命令用分号隔开,
      最后一条命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。
对 {} 和 () 而言, 括号中的重定向符只影响该条命令， 而括号外的重定向符影响到括号中的所有命令。


算术运算符
Shell 不能直接进行算数运算，必须使用数学计算命令。
如果不特别指明，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。
下表列出了常用的算术运算符 假定变量 a 为 10 变量 b 为 20
运算符  说明                          举例
+       加法                          `expr $a + $b` 结果为 30。
-       减法                          `expr $a - $b` 结果为 -10。
*       乘法                          `expr $a \* $b` 结果为  200。
/       除法                          `expr $b / $a` 结果为 2。
%       取余                          `expr $b % $a` 结果为 0。
=       赋值                          a=$b 把变量 b 的值赋给 a。
==      相等 两数字相同返回true        [ $a == $b ] 返回 false。
!=      不相等 两数字不相同返回true     [ $a != $b ] 返回 true。
**     幂运算
++、–   自增和自减，可以放在变量的前面也可以放在变量的后面
!、&&、||             逻辑非(取反)、逻辑与(and)、逻辑或(or)
<、<=、>、>=          比较符号(小于、小于等于、大于、大于等于)
==、!=、=             比较符号(相等、不相等；对于字符串，= 也可以表示相当于)
<<、>>                向左移位、向右移位
~、|、 &、^           按位取反、按位或、按位与、按位异或
=、+=、-=、*=、/=、%= 赋值运算符，例如 a+=1 相当于 a=a+1，a-=1 相当于 a=a-1
注意       条件表达式要放在[]之间

运算操作符/运算命令  说明
(())               用于整数运算，效率很高，推荐使用。不能对小数(浮点数)或者字符串进行运算。
let                用于整数运算，和 (()) 类似。
$[]                用于整数运算，不如 (()) 灵活。
expr               可用于整数运算，也可以处理字符串。比较麻烦，需要注意各种细节，不推荐使用。
bc                 Linux下一个计算器程序，可处理整数和小数。Shell 本身只支持整数运算，想计算小数就得使用 bc 这个外部的计算器。
declare -i         将变量定义为整数，然后再进行数学运算时就不会被当做字符串了。
  功能有限，仅支持最基本的数学运算(加减乘除和取余)，不支持逻辑运算、自增自减等，所以在实际开发中很少使用。
说明  推荐只使用 (()) 和 bc 即可，(()) 可以用于整数计算，bc 可以小数计算。

(()) 双小括号是 Bash Shell 中专门用来进行整数运算的命令
((expr))  # expr表达式可以有一个或多个，多个表达式之间以逗号,分隔，以最后一个表达式的值作为整个 (()) 命令的执行结果。
使用 $ 获取 (()) 命令的结果，这和使用 $ 获得变量值是类似的。
((a=10+66)) ((b=a-15))    # 这种写法可以在计算完成后给变量赋值 使用变量时不用加$前缀，(()) 会自动解析变量名。
a=$((10+66)) b=$((a-15))  # 在 (()) 前面加上$获取 (()) 命令的执行结果，即获取整个表达式的值。不加则出错
((a>7 && b==5))           # (()) 也可以进行逻辑运算，在 if 语句中常会使用逻辑运算。
echo $((a+10))            # 需要立即输出表达式的运算结果时，可以在 (()) 前面加$符号。
((a=3+5, b=a+10))         # 对多个表达式同时进行计算。
$((a++)) $((++a))         # 前自增/后自增
$((--a)) $((a–-))         # 前自减/后自减

let命令  和双小括号 (()) 的用法是类似的，它们都是用来对整数进行运算
let expr      # 其中的 expr 可以不加引号，也可以加单引号和双引号。
let "expr"    # 当表达式中含有 Shell 特殊字符(例如 |)时，需要用双引号 "" 或者单引号 '' 将表达式包围起来。
let 'expr'
let ret=expr  # 将表达式 expr 的运行结果保存到变量 ret 中
let 也支持一次性计算多个表达式，并且以最后一个表达式的值作为整个 let 命令的执行结果。但是，对于多个表达式之间的分隔符，
  let 和 (()) 是有区别的       let 命令以空格来分隔多个表达式；(()) 以逗号,来分隔多个表达式。

expr 命令是 evaluate expressions 的缩写，译为 “表达式求值”。
expr 是一个功能强大，并且比较复杂的命令，它除了可以实现整数计算，还可以结合一些选项对字符串进行处理，
  例如计算字符串长度、字符串比较、字符串匹配、字符串提取等。
语法 expr exprisson
exprisson中的运算符、数字、变量和小括号的左右两边至少要有一个空格，否则会报错。
exprisson有些特殊符号必须用反斜杠 \ 进行转义(屏蔽其特殊含义)，比如乘号 * 和小括号 ()，如果不用 \ 转义，
  那么 Shell 会把它们误解为正则表达式中的符号( * 对应通配符，() 对应分组)。
exprisson使用变量时要加 $ 前缀。
expr 10 + 20   # 注意空格  expr 10+20 则出错 只打印 10+20
expr 4 \* 5    # 注意转义字符 *
expr 2 + \( 4 \* 5 \)   # 注意转义字符 * ()

bc 命令可以很方便的进行浮点运算，当然整数运算也是支持的。
bc 甚至可以称得上是一种编程语言了，它支持变量、数组、输入输出、分支结构、循环结构、函数等基本的编程元素。
https://haicoder.net/shell/shell-bc.html
Shell中bc借助管道使用 bc 计算器。语法 echo "expression" | bc
echo "5+3" | bc
echo "(2+6)*3" | bc


关系运算符
关系运算符只支持数字，不支持字符串，除非字符串的值是数字。
下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20
运算符  说明                                                       举例
-eq     检测两个数是否相等，相等返回 true。                        [ $a -eq $b ] 返回 false。
-ne     检测两个数是否不相等，不相等返回 true。                    [ $a -ne $b ] 返回 true。
-gt     检测左边的数是否大于右边的，如果是，则返回 true。           [ $a -gt $b ] 返回 false。
-lt     检测左边的数是否小于右边的，如果是，则返回 true。           [ $a -lt $b ] 返回 true。
-ge     检测左边的数是否大于等于右边的，如果是，则返回 true。       [ $a -ge $b ] 返回 false。
-le     检测左边的数是否小于等于右边的，如果是，则返回 true。       [ $a -le $b ] 返回 true。

布尔运算符
下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20
运算符  说明                                                       举例
!       非运算，表达式为 true 则返回 false，否则返回 true。        [ ! false ] 返回 true。
-o      或运算，有一个表达式为 true 则返回 true。                  [ $a -lt 20 -o $b -gt 100 ] 返回 true。
-a      与运算，两个表达式都为 true 才返回 true。                  [ $a -lt 20 -a $b -gt 100 ] 返回 false。

逻辑运算符
以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20
运算符  说明          举例
&&      逻辑的 AND    [[ $a -lt 100 && $b -gt 100 ]]  返回 false
||      逻辑的 OR     [[ $a -lt 100 || $b -gt 100 ]]  返回 true
-a      逻辑的 AND    [ $a -lt 100 -a $b -gt 100 ]    返回 true
-o      逻辑的 OR     [ $a -lt 100 -o $b -gt 100 ]    返回 true
!       逻辑的 NOT    [[ !($a -lt 100) ]]             返回 false


字符串运算符
下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"
运算符  说明                                            举例
= 或 == 检测两个字符串是否相等，相等返回 true。         [ $a = $b ] 返回 false。
!=      检测两个字符串是否不相等，不相等返回 true。     [ $a != $b ] 返回 true。
-z      检测字符串长度是否为0，为0返回 true。           [ -z $a ] 返回 false。
-n      检测字符串长度是否不为 0，不为 0 返回 true。    [ -n "$a" ] 返回 true。
$       检测字符串是否不为空，不为空返回 true。         [ $a ] 返回 true。
str1 > str2 判断 str1 是否大于 str2 \>是转义字符，这样写是为了防止>被误认为成重定向运算符   [ $str1 \> $str2 ]
str1 < str2 判断 str1 是否小于 str2。 同样，\<也是转义字符


文件测试运算符
文件测试运算符用于检测 Unix 文件的各种属性。属性检测描述如下
操作符  说明                                                                        举例
-b file 检测文件是否是块设备文件，如果是，则返回 true。                          [ -b $file ] 返回 false。
-c file 检测文件是否是字符设备文件，如果是，则返回 true。                        [ -c $file ] 返回 false。
-d file 检测文件是否是目录，如果是，则返回 true。                                [ -d $file ] 返回 false。
-e file 检测文件(包括目录)是否存在，如果是，则返回 true。                       [ -e $file ] 返回 true。
-f file 检测文件是否是普通文件(既不是目录，也不是设备文件)，如果是，则返回 true。 [ -f $file ] 返回 true。
-g file 检测文件是否设置了 SGID 位，如果是，则返回 true。                        [ -g $file ] 返回 false。
-L file检测文件是否存在并且是一个符号链接。
-k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。              [ -k $file ] 返回 false。
-p file 检测文件是否是有名管道，如果是，则返回 true。                            [ -p $file ] 返回 false。
-u file 检测文件是否设置了 SUID 位，如果是，则返回 true。                        [ -u $file ] 返回 false。
-r file 检测文件是否可读，如果是，则返回 true。                                  [ -r $file ] 返回 true。
-w file 检测文件是否可写，如果是，则返回 true。                                  [ -w $file ] 返回 true。
-x file 检测文件是否可执行，如果是，则返回 true。                                [ -x $file ] 返回 true。
-s file 检测文件是否为空(文件大小是否大于0)，不为空返回 true。                  [ -s $file ] 返回 true。
-S file 判断该文件是否存在，并且是否为套接字文件，是W返回 true。                  [ -s $file ] 返回 true。

文件比较
选项             作用
file1 -nt file2  判断 file1 的修改时间是否比 file2 的新。
file1 -ot file2  判断 file1 的修改时间是否比 file2 的旧。
file1 -ef file2  判断 file1 是否和 file2 的 inode 号一致，这个用于判断硬链接是很好的方法



函数
1 使用函数前，必须先声明与定义函数。
函数定义
function func1() {          # 若关键字function省略 则()不能省略 否则 () 可省
    statements              # {} 包围的为函数体
    [return value]          # value必须为数字 return是Shell 关键字 若省则函数返回值为最后一条命令的退出状态
}

2 函数调用
func1 param1 param2 param3  # 函数名 参数
echo $?                     # 函数返回值 $? 是一个特殊变量 用来获取上一个命令的退出状态 或上一个函数的返回值

3 函数返回值
  1 通过全局变量的方式 函数内对全局变量赋值
  2 函数内 return value     只能返回数字
    函数内 echo xx1;echo xx2;return $?
      外部 以$(func param1 param2) 或者 `func param1 param2` 捕获之 可以赋值给一个变量
      注意 函数内echo不打印 而是把它们整合成一个变量放回 中间以空格分隔

4 函数参数
在Linux bash中，可以用以下三种方式解析命令行参数
直接处理     使用$1,$2,$3…进行解析
getopts     单个字符选项的情况                  如 -n 10 -f file.txt等选项
getopt      处理单个字符或长选项(long-option)   如 –prefix=/home等
经验        小型脚本可以直接处理，大多数情况使用getopts，getopt的功能更加强大。

eval
  1 把字符串当命令执行
bash-4.2$ # script="cat getopt.sh"
bash-4.2$  # eval $script
#!/bin/bash
rr=$(getopt ab:cd -a yyy -b test1 -cd test2 test3)
echo $rr

bash-4.2$  # eval "ll .."
total 3780
-rw-r--r--   1 root root    4096 Mar 13  2020 ?
drwxr-xr-x   2 root root    4096 Dec 24  2020 bin
……

  2 变量套用(最多两层)
bash-4.2$  # t=tttt
bash-4.2$  # tttt=tttttt
bash-4.2$  # eval echo \$$t
tttttt

set
将$1 $2 $3……设为固定的值  举例如下
bash-4.2$ # cat test.sh
#!/bin/bash
echo $1 $2 $3
set -- aa bb cc
echo $1 $2 $3
bash-4.2$ # sh test.sh a b c
a b c
aa bb cc

shift
将参数左移n个，也可以理解为删除前n个参数($0不受影响)
默认为1，shift 或 shift 1  都是取消 $1 ，而原本的 $2 则变为 $1、$3 变为 $2 ...
同理 shift 3 是取消前面三个参数，也就是原本的 $4 将变为 $1 所以使用 shift 9 则 原本的 $10 将变为 $1 举例如下
bash-4.2$ # cat test.sh
#!/bin/bash
set -- aa bb cc dd ee ff gg hh
echo $1 $2 $3 $4 $5 $6 $7 $8
shift 3
echo $1 $2 $3 $4 $5 $6 $7 $8
bash-4.2$ # sh test.sh
aa bb cc dd ee ff gg hh
dd ee ff gg hh

4.1 类似脚本参数 ./xx.sh p1 p2 p3   脚本中 $0 也表示当前脚本的文件名
函数内部 $0 当前脚本的文件名./xx.sh  $1 传给函数的第一个参数 p1  $2 第二个参数 p2  依次类推。
$# 传递的参数的个数           # 3
$* 一次性获取所有的参数       # "p1" "p2" "p3"  #将接收到的每个参数看做一份数据 彼此之间以空格来分隔 (传递了n个参数)
"$*" 一次性获取所有的参数     # "p1 p2 p3"      #以"$1 $2 … $n"的形式输出所有参数 (传递了一个参数)
$@ 一次性获取所有的参数       # 同$*
"$@" 一次性获取所有的参数     # "p1" "p2" "p3"  #以"$1" "$2" … "$n" 的形式输出所有参数 (传递了n个参数)同$@
$$                          # 脚本运行的当前进程ID号
$!                          # 后台运行的最后一个进程的ID号
$-                          # Shell使用的当前选项，与set命令功能相同
$?                          # 最后命令的退出状态。0没有错误，其他值有错误

注意 位参(positional parameter) 中的 $10 不是替換第10个参数，而是替換第1个参数($1)然后再补一个 0 于其后
如 ./my.sh a1 a2 a3 a4 a5 a6 a7 a8 a9 aa 中 $10 不是 aa 而是 a10
要抓到 aa，有两种方法
  1 ${} ，也就是用 ${10} 即可。
  2 shift 9


函数参数 默认分隔符为空格 若参数中有空格 处理方式2种
  1 用 "" 把参数包围起来
  2 修改分隔符
    IFS_BAK=$IFS       # 备份默认分隔符
    IFS="!!"           # 指定新的分隔符
    XXX
    IFS=$IFS_BAK       # 恢复系统默认分隔符

4.2 getopts optstring name [arg...]
getopts是bash的内部命令 有两个参数
optstring是一个选项字符串 包括字符和: 每一个字符都是一个有效选项
  字符后面带有: 表示这个选项有自己的参数，其值保存在内置变量 OPTARG 中，需要以空格分隔。如 d:  表示 -d value
  字符后面带有:: 表示这个选项有自己的参数的值可选。  如 d::  表示-d 或者 -d value
  冒号和问号不能被用作选项字符。getopts每次被调用时，它会将下一个选项字符放置到变量中，
  optstring 前面加冒号 则代表忽略错误
  OPTARG 总是存储原始$*中当前要处理的选项的参数 没有则为空  如  -d value 中 OPTARG 存储 value
  OPTIND 存放存储原始$*中下一个要处理的参数的index
  optstring 为 afs   # 识别-a，-f以及-s参数
  optstring 为 a:fs  # 表示a参数后面会有一个值出现，-a value的形式。

举例说明
bash getopts.sh -a 12 -b -c file1 file2     # 调用下面的脚本

#!/bin/bash

echo original parameters=[$*]               # original parameters=[-a 12 -b -c file1 file2]
echo original OPTIND=[$OPTIND]              # original OPTIND=[1]
while getopts ":a:bc" opt                   # 第一个冒号表示忽略错误
do
  case $opt in
    a)
      echo "this is -a option. OPTARG=[$OPTARG] OPTIND=[$OPTIND]"  # this is -a option. OPTARG=[12] OPTIND=[3]
      ;;
    b)
      echo "this is -b option. OPTARG=[$OPTARG] OPTIND=[$OPTIND]"  # this is -b option. OPTARG=[] OPTIND=[4]
      ;;
    c)
      echo "this is -c option. OPTARG=[$OPTARG] OPTIND=[$OPTIND]"  # this is -c option. OPTARG=[] OPTIND=[5]
      ;;
    ?)
      echo "there is unrecognized parameter."
      exit 1
      ;;
  esac
done
shift $(($OPTIND - 1))                      # 通过shift处理 $*中就只保留了除去选项内容的参数
echo remaining parameters=[$*]              # remaining parameters=[file1 file2]
echo \$1=[$1]                               # $1=[file1]
echo \$2=[$2]                               # $2=[file2]


4.3 getopt
getopt是一个外部命令，通常Linux发行版会自带
getopt支持短选项和长选项
增强版getopt比较好用，执行命令getopt -T; echo $?,如果输出4，则代表是增强版
如果短选项带argument且参数可选时，argument必须紧贴选项，例如-carg而不能是-c arg
如果长选项带argument且参数可选时，argument和选项之间用“=”，例如-–clong=arg而不能是-–clong arg
-o或--options选项后面是可接受的短选项，如ab:c::，表示可接受的短选项为-a -b -c，-a选项不接参数，-b必须接参数，-c参数为可选的
-l或--long选项后面是可接受的长选项，用逗号分开，冒号的意义同短选项。
-n选项后接选项解析错误时提示的脚本名字

举例说明
#!/bin/bash

echo original parameters=[$@]

ARGS=`getopt -o ab:c:: --long along,blong:,clong:: -n "$0" -- "$@"`
if [ $? != 0 ]; then
  echo "Terminating..."
  exit 1
fi

echo ARGS=[$ARGS]
eval set -- "${ARGS}"               # 将规范化后的命令行参数分配至位置参数($1,$2,...)
echo formatted parameters=[$@]

while true
do
  case "$1" in
    -a|--along)
      echo "Option a";
      shift
      ;;
    -b|--blong)
      echo "Option b, argument $2";
      shift 2
      ;;
    -c|--clong)
      case "$2" in
        "")
          echo "Option c, no argument";
          shift 2
          ;;
        *)
          echo "Option c, argument $2";
          shift 2;
          ;;
      esac
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "Internal error!"
      exit 1
      ;;
  esac
done

echo remaining parameters=[$@]      # 处理剩余的参数
echo \$1=[$1]
echo \$2=[$2]

测试结果
短选项
$ bash getopt.sh -a b1 -c2 file1 file2
original parameters=[-a b1 -c2 file1 file2]
ARGS=[ -a -c '2' -- 'b1' 'file1' 'file2']
formatted parameters=[-a -c 2 -- b1 file1 file2]
Option a
Option c, argument 2
remaining parameters=[b1 file1 file2]
$1=[b1]
$2=[file1]

长选项
$ bash getopt.sh --along --blong=1 --clong=2 file1 file2
original parameters=[--along --blong=1 --clong=2 file1 file2]
ARGS=[ --along --blong '1' --clong '2' -- 'file1' 'file2']
formatted parameters=[--along --blong 1 --clong 2 -- file1 file2]
Option a
Option b, argument 1
Option c, argument 2
remaining parameters=[file1 file2]
$1=[file1]
$2=[file2]

长短混合
$ bash getopt.sh -a -b1 --clong=2 file1 file2
original parameters=[-a -b1 --clong=2 file1 file2]
ARGS=[ -a -b '1' --clong '2' -- 'file1' 'file2']
formatted parameters=[-a -b 1 --clong 2 -- file1 file2]
Option a
Option b, argument 1
Option c, argument 2
remaining parameters=[file1 file2]
$1=[file1]
$2=[file2]

可选参数出错的情况
短选项和所带argument中间含有空格
$ bash getopt.sh -a -b 1 -c 2 file1 file2
original parameters=[-a -b 1 -c 2 file1 file2]
ARGS=[ -a -b '1' -c '' -- '2' 'file1' 'file2']
formatted parameters=[-a -b 1 -c -- 2 file1 file2]
Option a
Option b, argument 1
Option c, no argument
remaining parameters=[2 file1 file2]
$1=[2]
$2=[file1]

长选项和所带argument中间含有空格
$ bash getopt.sh --along --blong 1 --clong 2 file1 file2
original parameters=[--along --blong 1 --clong 2 file1 file2]
ARGS=[ --along --blong '1' --clong '' -- '2' 'file1' 'file2']
formatted parameters=[--along --blong 1 --clong -- 2 file1 file2]
Option a
Option b, argument 1
Option c, no argument
remaining parameters=[2 file1 file2]
$1=[2]
$2=[file1]



shell脚本里切换用户后继续执行
https://blog.csdn.net/alittleyatou/article/details/90025470
1 使用 <<EOF 参数实现
#!/bin/bash
su - wuzz <<EOF
pwd
echo "hello world"
EOF
2 使用命令行实现
  2.1 切换用户只执行少量语句
    su - wudata -c "cd /opt/wudata/datasync-client;pwd"
  2.2 切换用户执行脚本
    su - wudata -c "cd /opt/wudata/datasync-client;./wuzz.sh"    #用的是当前用户的环境变量
    su - wudata -s /bin/sh /opt/wuldata/datasync-client/wuzz.sh    #用的是wudata用户的环境变量

如
#!/bin/bash$
if [ ! -f "/usr/lib/aarch64-linux-gnu/libc.musl-aarch64.so.1" ];then$
#sudo su<<EOF                                                                                              # 1$
#echo 0 > /sys/block/vblkdev0/rw_mode; mount -o remount ,rw /                                              # 1$
#ln -s /usr/lib/aarch64-linux-gnu/libc.so.6 /usr/lib/aarch64-linux-gnu/libc.musl-aarch64.so.1              # 1$
#EOF                                                                                                       # 1$
sudo su -c "echo 0 > /sys/block/vblkdev0/rw_mode; mount -o remount ,rw /"                                  # 2$
sudo su -c "ln -s /usr/lib/aarch64-linux-gnu/libc.so.6 /usr/lib/aarch64-linux-gnu/libc.musl-aarch64.so.1"  # 2$
fi$
p=$(pwd)$
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$p/qt515:$p/lib$

# 1 2分别为2种实现 效果一样




[root@bogon ~]# cat 789.sh     每三秒过滤8123的 WEB CLOSE_WAIT 数量
#!/bin/bash
for ((i=1; i<=5000; i++))
do
echo `date`
netstat -antp | grep 8123 | grep CLOSE_WAIT | grep Web |  wc -l
sleep 3
done
[root@bogon ~]# cat 123.sh     每三秒 用curl 登录系统
#!/bin/bash
for ((i=1; i<=5000; i++))
do
echo `date`
curl --location --request GET 'http://192.168.11.40:8121/mxlogin.BSI?username=TXDCGuAvaJyMZHiNmIo2wQdez7bBPnYK'
sleep 3
done
[root@bogon ~]# cat 345.sh     每三秒过滤文件句柄
#!/bin/bash
for ((i=1; i<=5000; i++))
do
echo `date`
lsof -n|grep WebExpress| awk '{print $2}'|sort|uniq -c|sort -nr|more
sleep 3
done
