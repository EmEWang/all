

sudo apt install cmake     #Ubuntu中安装Cmake 此种方式安装的可能不是最新版本的Cmake
sudo apt-get remove cmake  #卸载原来的cmake版本

https://cmake.org/download/  #下载cmake源码，如cmake-3.17.1.tar.gz Cmake源码编译安装
tar -zxv -f cmake-3.17.1.tar.gz #在cmake源码所在文件夹中打开命令终端，解压文件
./bootstrap
  sudo apt-get install g++         #更新g++ 若提示 cannot find a c++ compiler that supports
  sudo apt-get install libssl-dev  #安装库 若提示 could not find openssl
make
sudo make install

cmake --version   #验证安装版本



cmake 调用格式
1 cmake -Dvar="value>" cmake_file  #-D 为配置或编译参数  如 cmake -DCMAKE_CXX_COMPILER="clang++" -DCMAKE_CXX_FLAGS="-std=c++11 -stdlib=libc++" ../source #c++编译器为clang c++编译参数为-std=c++11 -stdlib=libc++  CMakeLists.txt 位置在 ../source
2 cmake -i 或 ccmake 交互式界面
3 cmake ctest 在CMakeLists.txt 增加了add_test 执行单元测试
4 cmake --trace / --trace-expand  详细记录调用过程和处理

透過使用 SET 語法， set(CMAKE_VERBOSE_MAKEFILE TRUE)，可以在 CMakeLists.txt 中將 CMAKE_VERBOSE_MAKEFILE 屬性設為 TRUE 。一旦 CMAKE_VERBOSE_MAKEFILE 為 True，可以讓 make 在執行時是 verbose output。



CMakeLists.txt 中的格式与命令
https://www.hahack.com/codes/cmake/

cmake_minimum_required(VERSION 3.5)     #设置cmake 的最低版本
project (hello_cmake)                   #设置项目名称
add_executable(TARGET_NAME SOURCES)     #生成可执行目标  如 add_executable(example main.cpp main.h)
add_library(TARGET_NAME [STATIC | SHARED | MODULE] SOURCES)   #生成库
aux_source_directory(. DIR_SRCS)        #查找当前目录下的所有源文件 并将名称保存到 DIR_SRCS 变量
add_subdirectory(math)                  #添加 math 子目录 也就是math下有 子 CMakeLists.txt
set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)  #设置变量

target_compile_definitions(TARGET_NAME INTERFACE|PUBLIC|PRIVATE DEFINITION) #编译 -D 选项
target_compile_options(TARGET_NAME INTERFACE|PUBLIC|PRIVATE OPTION)   #指定目标的编译选项。
target_link_libraries(TARGET_NAME PRIVATE|PUBLIC|INTERFACE LIBRARY)   #对 TARGET_NAME 建立 LIBRARY 连接时。LIBRARY 一个/多个 library 的名字 绝对路径 LIBRARY 名称(libcomm.so comm -lcomm 均可)。
target_include_directories(TARGET_NAME INTERFACE|PUBLIC|PRIVATE DIR)  #编译 TARGET_NAME 时，增加 DIR 目录到头文件搜索路径。

include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) #相当于g++选项中的-I参数的作用，也相当于环境变量中增加路径到CPLUS_INCLUDE_PATH变量的作用。
link_directories(directory1 directory2 ...) #相当于g++命令的-L选项的作用，也相当于环境变量中增加LD_LIBRARY_PATH的路径的作用。
link_libraries(library1 <debug | optimized> library2 ...) # 添加需要链接的库文件路径 中间使用空格分隔.
find_library (<VAR> name1 [path1 path2 ...]) #查找库

OPTION(OPTION_NAME HELP_MESSAGE DEFAULT_VALUE)  #建立使用者选项参数
message([MODE] "message to display")  #message 是 CMake 的 print MODE 必須填入 CMake 提供的常熟选项
execute_process(COMMAND CMD_NAME [ARGUMENTS...] [ERROR_VARIABLE VARIABLE_NAME])  #执行子程序 CMD_NAME 是要执行的程序 ARGUMENTS 要执行程序的参数 VARIABLE_NAME 程序执行时失败时 将设置为true的变量

举例
target_compile_definitions(foo PUBLIC DEBUG)，定义了 DEBUG 符号
target_compile_options(o_util PUBLIC "-Wno-error=comment") 增加编译选项 "-Wno-error=comment" 编译 o_util 的时候
include_directories(../../../thirdparty/comm/include)
link_directories("/home/server/third/lib")
link_libraries("/opt/libeng.so"　"/opt/libmx.so")
FIND_LIBRARY(RUNTIME_LIB rt /usr/lib  /usr/local/lib NO_PATH) cmake在目录中查找，若目录中都没有，值RUNTIME_LIB就会被赋为NO_PATH
option(DOWN_M "Download" ON) 建立DOWN_M，默认为 ON
execute_process(COMMAND python ${CMAKE_CURRENT_LIST_DIR}/../tools/download_mnist.py -d ${CMAKE_BINARY_DIR}/data ERROR_VARIABLE DOWNLOAD_ERROR)


include(CheckCXXCompilerFlag)    #检查 CXX 编译器是否支持给定的标志 必须先包含
CHECK_CXX_COMPILER_FLAG("-std=c++11" COMPILER_SUPPORTS_CXX11)     #检测是否支持c11 并将结果赋给 COMPILER_SUPPORTS_CXX11
CHECK_CXX_COMPILER_FLAG("-std=c++0x"COMPILER_SUPPORTS_CXX0X)      #检测是否支持 c0x
CHECK_CXX_COMPILER_FLAG(-Wdate-time COMPILER_SUPPORTS_WDATE_TIME) #检测是否支持 -Wdate-time 即 __DATE__, __TIME__, or __TIMESTAMP__这几个宏

定制安装规则 #CMakeLists.txt 文件里添加
install (TARGETS MathFunctions DESTINATION bin)      #libMathFunctions.o 文件会被复制到 /usr/local/bin 中
install (FILES MathFunctions.h DESTINATION include)  #MathFunctions.h 文件会被复制到 /usr/local/include 中
set(CMAKE_INSTALL_PREFIX "/path/to/subdir") #/usr/local/ 是默认安装根目录 修改 CMAKE_INSTALL_PREFIX 变量指定根目录

添加测试  #CMakeLists.txt 文件里添加
enable_testing()               #启用测试
add_test (test_run Demo 5 2)   #测试程序是否成功运行
make test                      #运行测试案例

支持 gdb
set(CMAKE_BUILD_TYPE "Debug")
set(CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS} -O0 -Wall -g -ggdb")
set(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS} -O3 -Wall")


编译选项设置--------
在CMakeLists.txt中可以通过修改CMake内置的环境变量来改变C或C++的编译选项.
编译选项相关的CMake 变量如下：

CMAKE_C_FLAGS =
CMAKE_C_FLAGS_DEBUG = -g
CMAKE_C_FLAGS_MINSIZEREL = -Os -DNDEBUG
CMAKE_C_FLAGS_RELEASE = -O3 -DNDEBUG
CMAKE_C_FLAGS_RELWITHDEBINFO = -O2 -g -DNDEBUG

CMAKE_CXX_FLAGS =
CMAKE_CXX_FLAGS_DEBUG = -g
CMAKE_CXX_FLAGS_MINSIZEREL = -Os -DNDEBUG
CMAKE_CXX_FLAGS_RELEASE = -O3 -DNDEBUG
CMAKE_CXX_FLAGS_RELWITHDEBINFO = -O2 -g -DNDEBUG

对于C语言设置CMAKE_C_FLAGS相关参数，C++语言设置CMAKE_CXX_FLAGS相关参数。并且分为DEBUG，RELEASE，MINSIZEREL和RELWITHDEBINFO四种类型。

以C++语言编译选项为例：
CMAKE_CXX_FLAGS_DEBUG：编译Debug版本的时候会采用的编译选项，默认只有一个-g选项，包含调试信息；
CMAKE_CXX_FLAGS_RELEASE：编译Release版本的时候采用的编译选项，默认包-O3选项，该选项表示优化等级；
CMAKE_CXX_FLAGS_MINSIZEREL：主要减小目标文件大小，选项-Os就是这个作用；
CMAKE_CXX_FLAGS_RELWITHDEBINFO：包含调试信息的Release版本，-O2和-g，优化的同时也包含了调试信息；
CMAKE_CXX_FLAGS：这个选项没有默认值；

顾名思义，当CMake在编译项目的时候，选项为Debug则会采用CMAKE_CXX_FLAGS_DEBUG选项，编译Release则会采用CMAKE_CXX_FLAGS_RELEASE选项，因此，需要设置编译选项的时候，在CMakeLists.txt中设置这些变量就可以了。

实际上可以分别设置CMAKE_CXX_FLAGS_DEBUG和CMAKE_CXX_FLAGS_RELEASE，如下：
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -std=c++11 -Wl,-rpath=../lib")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -std=c++11 -g")

上面的设置两个都有-std=c++11，这个选项是一个公共的选项，不管是Release还是Debug都需要设置。这种情况还可以把公共的设置放在CMAKE_CXX_FLAGS变量里面，如下：

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}  -Wl,-rpath=../lib")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -g")
因为在最终编译的时候的编译选项不管是Release还是Debug都包含了CMAKE_CXX_FLAGS这个变量。

打印消息---------------
message方法
message([<mode>] "message to display" ...)
message：消息名字，可在CMakeLists.txt或者.cmake脚本文件中输入，且有提示，不区分大小写
mode：打印消息的类别，有FATAL_ERROR，SEND_ERROR，WARNING，AUTHOR_WARNING，DEPRECATION，(none) or NOTICE，STATUS，VERBOSE，DEBUG，TRACE共10种
“message to display”：输出消息的内容，是字符串类型
…：表示可变参数，可连接多个输出

mode说明  STATUS 输出到 stdout，其他到 stderr
FATAL_ERROR：cmake出错，停止编译和生成(信息红色)
SEND_ERROR：cmake出错，继续编译，但是停止生成(信息红色)
WARNING：cmake警告，继续编译(信息红色)
AUTHOR_WARNING：开发者警告，继续编译(信息红色)
DEPRECATION：如果使用set方法设置CMAKE_ERROR_DEPRECATED为true(不区分大小写)，编译出错，否则继续编译
(none) or NOTICE：不设置mode，默认是NOTICE模式，不影响编译和生成，用于打印消息(信息白色)
STATUS：编译时状态信息，左边以--开头(信息白色)
DEBUG：针对开发人员的调试信息(信息白色)
TRACE：日志级别的临时信息(信息白色)



使用CMake交叉编译Arm Linux程序
https://blog.csdn.net/whahu1989/article/details/104114515
https://zhuanlan.zhihu.com/p/100367053

在 CMakeLists.txt 同级目录下 新建文件 aarch_linux.cmake 内容如下:

set(CMAKE_SYSTEM_NAME Linux)      #即目标系统名 这里是Linux 该指令必须存在 1)
set(CMAKE_SYSTEM_PROCESSOR arm)   #目标系统的处理器名，这里是arm

# set(tools /usr/)
# set(CMAKE_C_COMPILER ${tools}/bin/aarch64-linux-gnu-gcc)
# set(CMAKE_CXX_COMPILER ${tools}/bin/aarch64-linux-gnu-g++)

set(tools /usr/bin)
set(CMAKE_C_COMPILER ${tools}/aarch64-linux-gnu-gcc)   #C编译器的可执行文件名称 2)
set(CMAKE_CXX_COMPILER ${tools}/aarch64-linux-gnu-g++) #C++编译器的可执行文件名称

注:
1) 支持Linux，QNX，WindowsCE，Android等。如果没有操作系统，那么就写 Generic。执行该指令后，cmake 变量——CMAKE_CROSSCOMPILING 会自动被设置为 TRUE，此时 cmake 就会“知道“现在执行的是交叉编译
2)由于 cmake 无法自动获取目标机器信息，因此需要显式指明编译工具。
3)上述命令必须写入脚本中，使用 -DCMAKE_TOOLCHAIN_FILE=xxx.cmake 的方式使用。不能直接写入 CMakeLists.txt 或使用 include(xx.cmake)

编译
mkdir build
cd build
cmake -DCMAKE_TOOLCHAIN_FILE=../aarch_linux.cmake ..     #使用CMake的变量CMAKE_TOOLCHAIN_FILE来指定工具链文件
make






target_** 中的 PUBLIC，PRIVATE，INTERFACE
https://zhuanlan.zhihu.com/p/82244559

测试工程目录结构：
cmake-test/                 工程主目录，main.c 调用 libhello-world.so
├── CMakeLists.txt
├── hello-world             生成 libhello-world.so，调用 libhello.so 和 libworld.so
│   ├── CMakeLists.txt
│   ├── hello               生成 libhello.so
│   │   ├── CMakeLists.txt
│   │   ├── hello.c
│   │   └── hello.h         libhello.so 对外的头文件
│   ├── hello_world.c
│   ├── hello_world.h       libhello-world.so 对外的头文件
│   └── world               生成 libworld.so
│       ├── CMakeLists.txt
│       ├── world.c
│       └── world.h         libworld.so 对外的头文件
└── main.c

调用关系：
                                 ├────libhello.so
可执行文件────libhello-world.so
                                 ├────libworld.so
关键字用法说明：

1 PRIVATE：私有的。生成 libhello-world.so时，只在 hello_world.c 中包含了 hello.h，libhello-world.so 对外的头文件——hello_world.h 中不包含 hello.h。而且 main.c 不会调用 hello.c 中的函数，或者说 main.c 不知道 hello.c 的存在，那么在 hello-world/CMakeLists.txt 中应该写入：
target_link_libraries(hello-world PRIVATE hello)
target_include_directories(hello-world PRIVATE hello)

2 INTERFACE：接口。生成 libhello-world.so 时，只在libhello-world.so 对外的头文件——hello_world.h 中包含 了 hello.h， hello_world.c 中不包含 hello.h，即 libhello-world.so 不使用 libhello.so 提供的功能，只使用 hello.h 中的某些信息，比如结构体。但是 main.c 需要使用 libhello.so 中的功能。那么在 hello-world/CMakeLists.txt 中应该写入：
target_link_libraries(hello-world INTERFACE hello)
target_include_directories(hello-world INTERFACE hello)

3 PUBLIC：公开的。PUBLIC = PRIVATE + INTERFACE。生成 libhello-world.so 时，在 hello_world.c 和 hello_world.h 中都包含了 hello.h。并且 main.c 中也需要使用 libhello.so 提供的功能。那么在 hello-world/CMakeLists.txt 中应该写入：
target_link_libraries(hello-world PUBLIC hello)
target_include_directories(hello-world PUBLIC hello)

实际上，这三个关键字指定的是目标文件依赖项的使用范围（scope）或者一种传递（propagate）。
可执行文件依赖 libhello-world.so， libhello-world.so 依赖 libhello.so 和 libworld.so。
1 main.c 不使用 libhello.so 的任何功能，因此 libhello-world.so 不需要将其依赖—— libhello.so 传递给 main.c，hello-world/CMakeLists.txt 中使用 PRIVATE 关键字；
2 main.c 使用 libhello.so 的功能，但是libhello-world.so 不使用，hello-world/CMakeLists.txt 中使用 INTERFACE 关键字；
3 main.c 和 libhello-world.so 都使用 libhello.so 的功能，hello-world/CMakeLists.txt 中使用 PUBLIC 关键字；

include_directories(dir)
target_include_directories() 的功能完全可以使用 include_directories() 实现。还是建议使用 target_include_directories()。
include_directories(header-dir) 是一个全局包含，向下传递。什么意思呢？就是说如果某个目录的 CMakeLists.txt 中使用了该指令，其下所有的子目录默认也包含了header-dir 目录。

上述例子中，如果在顶层的 cmake-test/CMakeLists.txt 中加入：
include_directories(hello-world)
include_directories(hello-world/hello)
include_directories(hello-world/world)

那么整个工程的源文件在编译时都会增加：
-I hello-world -I hello-world/hello -I hello-world/world ...
各级子目录中无需使用 target_include_directories() 或者 include_directories()了。如果此时查看详细的编译过程（make VERBOSE=1）就会发现编译过程是一大坨，很不舒服。
当然了，在最终子目录的 CMakeLists.txt 文件中，使用 include_directories() 和 target_include_directories() 的效果是相同的。

4. 目录划分
每一个目录都是一个模块，目录内部应将对外和对内的头文件进行区分，由模块的调用者决定模块是否被传递（PRIVATE，INTERFACE，PUBLIC）。
