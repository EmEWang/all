


ifconfig eth0 up / ifconfig eth0 down  #启动关闭指定网卡
ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0配置IPv6地址
ifconfig eth0 del 33ffe:3240:800:1005::2/64 为网卡eth0删除IPv6地址
ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE #用ifconfig修改MAC地址
ifconfig eth0 192.168.120.56  #给eth0网卡配置IP地：192.168.120.56
ifconfig eth0 192.168.120.56 netmask 255.255.255.0 #给eth0网卡配置IP地址：192.168.120.56 ，并加上子掩码：255.255.255.0
ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255 # /给eth0网卡配置IP地址：192.168.120.56，加上子掩码：255.255.255.0，加上个广播地址： 192.168.120.255
ifconfig eth0 arp / ifconfig eth0 -arp #启用和关闭ARP协议
ifconfig eth0 mtu 1500                 #设置最大传输单元

ifconfig 字段含义说明：
eth0/eth1:           分别表示第一块网卡和第二块网卡；
lo:                       表示回环测试接口，注意，这个虚拟的interface一定要存在！
usb0:                  表示USB接口的网卡；
Linkencap:         表示位于OSI物理层的名称，即连接类型Ethernet（以太网）
HWaddr:             表示网卡的硬件地址，即MAC地址
inetaddr:             表示网卡IP；
Bcast:                 表示广播(broadcast ) 的地址；
Mask:                 表示子网掩码；
UP:                     表示网卡开启状态；
BROADCAST:  表示支持广播；
MULTICAST:   表示网卡混杂模式；
RUNNING:        表示网卡的网线被接上；
MULTICAST:    表示支持组播；
MTU:                  表示MaximumTrasmission Unit 最大传输单元(字节)，即此接口一次所能传输的最大封包；
Metric:                 表示路由度量值，缺省值是0；
RX:                      表示网络由激活到目前为止接收的数据包；
TX:                      表示网络由激活到目前为止发送的数据包；
collisions:            表示网络信号冲突的情况；
txqueuelen:          表示传输缓冲区长度大小；
Memory:             表示占用内存范围。



TCP 和 UDP 可以同时绑定相同的端口
  TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。因此， TCP/UDP 各自的端口号也相互独立，互不影响。
多个 TCP 服务进程可以同时绑定同一个端口吗？
  如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。如果两个 TCP 服务进程绑定的端口都相同，而 IP 地址不同，那么执行 bind() 不会出错。
如何解决服务端重启时，报错“Address already in use”的问题？
  重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误。要解决这个问题，我们可以对 socket 设置 SO_REUSEADDR 属性。这样即使存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，依然可以正常绑定成功，因此可以正常重启成功。
客户端的端口可以重复使用吗？
  在客户端执行 connect 函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。所以，如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。
客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？
  要看客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。即使在这种状态下，还是可以与其他服务器建立连接的，只要客户端连接的服务器不是同一个，那么端口是重复使用的。
如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？
  打开 net.ipv4.tcp_tw_reuse 这个内核参数。因为开启了这个内核参数后，客户端调用 connect 函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态。如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。




wlndows怎么解除防火墙对UDP限制
Windows防火墙->高级设置->入站规则->新建规则->自定义->协议端口中选择udp->其他步都默认 最后写个名称







