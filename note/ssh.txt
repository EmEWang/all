
ssh 服务安装
要在Ubuntu主机开启SSH服务，需要开启openssh-server
命令：
1、执行下句，下载SSH服务
sudo apt-get install openssh-server
2、执行下句，验证下载后是否已经开启了服务：
ps -e | grep ssh
如果只有ssh-agent表示还没启动。
3、执行下句，开启服务
/etc/init.d/ssh start
如果显示sshd则说明已启动成功。

密码登录
ssh user@host  远程登录 用户名user 登录远程主机host
ssh host       本地用户名与远程用户名一致 登录时可以省略用户名
ssh -p 2222 user@host   SSH 的默认端口是22 使用p参数可以修改这个端口
第一次登录对方主机，系统会出现下面的提示 yes  host主机已经得到认可 输入密码 登录成功
远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。
下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。
每个 SSH 用户都有自己的known_hosts文件，此外系统也有一个这样的文件，
通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥
windows一般在下在C:\Users\用户\.ssh\目录下

密钥登陆
ssh-keygen   生成密钥
  -t rsa 指定密钥的加密算法 一般为dsa或rsa -C username@host 为密钥文件指定新的注释
  -b 1024 指定密钥的二进制位数 -f mykey 指定生成的私钥文件 -F example.com  检查某个主机名是否在known_hosts文件里面
  -N secretword 指定私钥的密码 -p 重新指定私钥的密码(与-N的不同之处在于，新密码不在命令中指定，而是执行后再输入)
  -R example.com 将指定的主机公钥指纹移出known_hosts文件
运行结束以后 在$HOME/.ssh/目录下 会新生成两个文件:id_rsa.pub和id_rsa 前者是你的公钥 后者是你的私钥
ssh-copy-id user@host  将公钥传送到远程主机 host 上面
如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面#注释是否取掉。
  RSAAuthentication yes
  PubkeyAuthentication yes
  AuthorizedKeysFile .ssh/authorized_keys
然后，重启远程主机的 SSH 服务。
/* ubuntu系统 */
service ssh restart
/* debian系统 */
/etc/init.d/ssh restart

authorized_keys文件
远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。
公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。
这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：
$ ssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub
这条命令由多个语句组成，依次分解开来看：
$ ssh user@host，表示登录远程主机；
单引号中的mkdir .ssh && cat >> .ssh/authorized_keys，表示登录后在远程 Shell 上执行的命令：
$ mkdir -p .ssh"的作用是，如果用户主目录中的.ssh`目录不存在，就创建一个；
cat >> .ssh/authorized_keys < ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。
写入authorized_keys文件后，公钥登录的设置就完成啦

config文件
命令行参数   如-p 10086, -i /path/to/identity_file 等选项来设置SSH的端口号或认证证书位置
用户配置文件 ~/.ssh/config
系统配置文件 /etc/ssh/ssh_config
配置文件可分为多个配置区段，每个配置区段使用Host来区分。我们可以在命令行中输入不同的host来加载不同的配置段
对每一个配置项来说，首次获取的参数值将被采用，因此通用的设置应该放到文件的后面，特定host相关的配置项应放到文件的前面
Host host1
 别名
HostName ip或者url            远程主机名 主机名
User username1                登录用户名
Port 22                       端口 默认为 22
IdentityFile ~/.ssh/dc_1      私钥文件路径 默认为 ~/.ssh/id_dsa, ~/.ssh/id_ecdsa, ~/.ssh/id_ed25519 或 ~/.ssh/id_rsa中的一个
IdentitiesOnly                      只接受SSH key 登录            不常用
PreferredAuthentications publickey  强制使用Public Key验证        不常用

绑定本地端口
既然 SSH 可以传送数据，那么我们可以让那些不加密的网络连接，全部改走 SSH 连接，从而提高安全性。
假定我们要让8080端口的数据，都通过 SSH 传向远程主机，命令就这样写：
$ ssh -D 8080 user@host
SSH 会建立一个 Socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到 SSH 连接上面，发往远程主机。
可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。


SSL SSH OpenSSH OpenSSL
ssl是通讯链路的附加层。可以包含很多协议。https, ftps, .....
ssh只是加密的shell，最初是用来替代telnet的。通过port forward，也可以让其他协议通过ssh的隧道而起到加密的效果。
SSL是一种国际标准的加密及身份认证通信协议，您用的浏览器就支持此协议。SSL（Secure Sockets Layer）最初是由美国Netscape公司研究出来的，后来成为了Internet网上安全通讯与交易的标准。SSL协议使用通讯双方的客户证书以及CA根证书，允许客户/服务器应用以一种不能被偷听的方式通讯，在通讯双方间建立起了一条安全的、可信任的通讯通道。它具备以下基本特征：信息保密性、信息完整性、相互鉴定。 主要用于提高应用程序之间数据的安全系数。SSL协议的整个概念可以被总结为：一个保证任何安装了安全套接字的客户和服务器间事务安全的协议，它涉及所有TC/IP应用程序。
SSH的英文全称是Secure SHell。通过使用SSH，你可以把所有传输的数据进行加密，这样“中间人”这种攻击方式就不可能实现了，而且也能够防止DNS和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替telnet，又可以为ftp、pop、甚至ppp提供一个安全的“通道”。SSH是由客户端和服务端的软件组成的，有两个不兼容的版本分别是：1.x和2.x。用SSH 2.x的客户程序是不能连接到SSH 1.x的服务程序上去的。OpenSSH 2.x同时支持SSH 1.x和2.x。SSH的安全验证是如何工作的从客户端来看，SSH提供两种级别的安全验证。第一种级别（基于口令的安全验证）只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。第二种级别（基于密匙的安全验证）需要依靠密匙，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在你在该服务器的家目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒。
OpenSSL------一个C语言函数库，是对SSL协议的实现。
OpenSSH-----是对SSH协议的实现。
ssh 利用 openssl 提供的库。openssl 中也有个叫做 openssl 的工具，是 openssl 中的库的命令行接口。
从编译依赖上看：
openssh依赖于openssl，没有openssl的话openssh就编译不过去，也运行不了。
HTTPS可以使用TLS或者SSL协议，而openssl是TLS、SSL协议的开源实现，提供开发库和命令行程序。openssl很优秀，所以很多涉及到数据加密、传输加密的地方都会使用openssl的库来做。
可以理解成所有的HTTPS都使用了openssl。以root身份执行命令：grep -l 'libssl.*deleted' /proc/*/maps | tr -cd 0-9\\n | xargs -r ps u，可以看到哪些进程加载了老版本的openssl库。



