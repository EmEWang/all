
gcc编译选项-lpthread和-pthread的区别
1、-lpthread是较为老式的解决方法，pthread新加了对于宏D_REENTRANT的定义，-pthread会被展开为“-D_REENTRANT -lpthread”，
  它不仅可以链接pthread库，还可以打开系统头文件中的各种多线程支持分支，比如，我们常常使用的错误码标志errno，
  如果没有定义_REENTRANT，则实现为一个全局变量；若是定义了_REENTRANT，则会实现为每线程独有，从而避免线程竞争错误。
2、-pthread可移植性较强：在Linux中，pthread是作为一个单独的库存在的（libpthread.so），但是在其他Unix变种中却不一定，
  比如在FreeBSD中是没有单独的pthread库的，因此在FreeBSD中不能使用-lpthread来链接pthread，
  而使用-pthread则不会存在这个问题，因为FreeBSD的编译器能正确将-pthread展开为该系统下的依赖参数。
  同样道理，其他不同的变种也会有这样那样的区别，如果使用-lpthread，则可能在移植到其他Unix变种中时会出现问题，
  为了保持较高的可移植性，我们最好还是使用-pthread（尽管这种做法未被接纳成为C标准，但已基本是事实标准）。
结论用-pthread 如：gcc -pthread -o test test.c


gcc/g++
  -M  生成文件关联的信息。包含目标文件所依赖的所有原始码你能用gcc -M hello.c
  -MD 和-M相同，不过输出将导入到.d的文件里面
  -MM 和-M基本相同，不过将忽略由 系统库 造成的依赖关系  
  -MMD 和-MM相同，不过输出将导入到.d的文件里面
  -C 在预处理的时候,不删除注释信息,一般和-E使用,有时候分析程式，用这个非常方便的
  -std=c++0x    使用c++0x
  -std=c++11    使用c++11
  -fpic 编译器就生成位置无关目标码.适用于共享库(shared library).
  -fPIC 编译器就输出位置无关目标码.适用于动态连接(dynamic linking),即使分支需要大范围转移.
  -v 显示详细的编译、汇编、连接命令


