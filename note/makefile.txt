
将make的输出重定向到文件
数字    含义                   标准叫法
0      标准输入        stdin = standard input
1      标准输出        stdout = standard output
2      标准错误输出   stderr = standard error

【用法】
1.想要把make输出的全部信息，输出到某个文件中，最常见的办法就是：
make xxx > build_output.txt
此时默认情况是没有改变2=stderr的输出方式，还是屏幕，所以，如果有错误信息，还是可以在屏幕上看到的。
2.只需要把make输出中的错误（及警告）信息输出到文件中ing，可以用：
make xxx 2> build_output.txt
相应地，由于1=stdout没有变，还是屏幕，所以，那些命令执行时候输出的正常信息，还是会输出到屏幕上，你还是可以在屏幕上看到的。
3.只需要把make输出中的正常（非错误，非警告）的信息输出到文件中，可以用：
make xxx 1> build_output.txt
相应地，由于2=stderr没有变，还是屏幕，所以，那些命令执行时候输出的错误信息，还是会输出到屏幕上，你还是可以在屏幕上看到的。
4.想要把正常输出信息和错误信息输出到分别的文件中，可以用：
make xxx 1> build_output_normal.txt 2>build_output_error.txt
即联合使用了1和2，正常信息和错误信息，都输出到对应文件中了。
5. 所有的信息都输出到同一个文件中：
make xxx > build_output_all.txt 2>&1
其中的2>&1表示错误信息输出到&1中，而&1，指的是前面的那个文件：build_output_all.txt 。
注意：上面所有的1,2等数字，后面紧跟着大于号'>' ，中间不能有空格

(在命令行中 直接使用 xxx &> build_output_all.txt 表示所有的信息都输出到同一个文件中)



编译选项
https://www.cnblogs.com/lidabo/p/6068448.html
CC      #一般指 gcc
CXX     #一般指 g++
CPPFLAGS   #预处理阶段的选项
CFLAGS     #C 编译器的选项
CXXFLAGS   #C++ 编译器的选项 这两个变量实际上涵盖了编译和汇编两个步骤
LDFLAGS    #传递给连接器的选项





sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
https://www.cnblogs.com/openix/archive/2012/04/17/2453833.html
https://blog.csdn.net/chezhai/article/details/80047990

%.d: %.c
　$(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
　sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
　rm -f $@.$$$$

本人用的是下面这个
seq.d : seq.c
  @set -e; \
  gcc -MM $< > $@.$$$$; \
  sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
  rm -f $@.$$$$

-include seq.d

第一个命令
@set -e    #@关键字告诉make不输出该行命令；set -e的作用是，当后面的命令的返回值非0时，立即退出。
那么为什么要把几个命令写在”同一行“（是对于make来说，因为\的作用就是连接行），并用分号隔开每个命令？因为在Makefile这样做才能使上一个命令作用于下一个命令。这里是想要set -e作用于后面的命令。

第二个命令
gcc -MM $< > $@.$$$$
作用是根据源文件生成依赖关系，并保存到临时文件中。内建变量 $< 的值为第一个依赖文件(那seq.c)，
$$$$ 为字符串 "$$" 由于makefile中所有的$字符都是特殊字符(即使在单引号之中)，要得到普通字符$，需要用 $$ 来转义; 而 $$ 是shell的特殊变量，它的值为当前进程号；使用进程号为后缀的名称创建临时文件，是shell编程常用做法，这样可保证文件唯一性。

第三个命令作用是将目标文件加入依赖关系的目录列表中，并保存到目标文件。
sed替换命令格式是‘s///g’，若没有g，只对第一次匹配替换。注意‘/’分隔符可以替换,通过在’s’之后指定一个不同的字符来更改分隔符。
如果需要在规则表达式中使用分隔符，可以在它前面加入反斜杠。
如 d –e ‘s:/usr/local:/usr:g’ mylist.txt  #把所有出现的/usr/local替换成/usr  使用冒号作为分隔符
关于\(\)是保留的模式空间，\($*\)表示匹配$*,后面使用\1表示它；\(\)出现一次用\1匹配，如果出现多次，分别用\2、\3...匹配
$* 是makefile中匹配的“茎”，表示去掉文件的后缀，只留下基础名字，值为第一个依赖文件去掉后缀的名称(这里即是seq)。
\.表示点"."

第四个命令是将该临时文件删除。

